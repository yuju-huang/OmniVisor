.\" Automatically generated by Podwrapper::Man 1.21.8 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "nbdkit-plugin 3"
.TH nbdkit-plugin 3 "2020-06-10" "nbdkit-1.21.8" "NBDKIT"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
nbdkit\-plugin \- how to write nbdkit plugins
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& #define NBDKIT_API_VERSION 2
\& #include <nbdkit\-plugin.h>
\& 
\& #define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_ALL_REQUESTS
\& 
\& static void *
\& myplugin_open (void)
\& {
\&   /* create a handle ... */
\&   return handle;
\& }
\& 
\& static struct nbdkit_plugin plugin = {
\&   .name              = "myplugin",
\&   .open              = myplugin_open,
\&   .get_size          = myplugin_get_size,
\&   .pread             = myplugin_pread,
\&   .pwrite            = myplugin_pwrite,
\&   /* etc */
\& };
\& NBDKIT_REGISTER_PLUGIN(plugin)
.Ve
.PP
Compile the plugin as a shared library:
.PP
.Vb 1
\& gcc \-fPIC \-shared myplugin.c \-o myplugin.so
.Ve
.PP
and load it into nbdkit:
.PP
.Vb 1
\& nbdkit [\-\-args ...] ./myplugin.so [key=value ...]
.Ve
.PP
When debugging, use the \fI\-fv\fR options:
.PP
.Vb 1
\& nbdkit \-fv ./myplugin.so [key=value ...]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An nbdkit plugin is a new source device which can be served using the
Network Block Device (\s-1NBD\s0) protocol.  This manual page describes how
to create an nbdkit plugin in C.
.PP
To see example plugins:
https://github.com/libguestfs/nbdkit/tree/master/plugins
.PP
To write plugins in other languages, see:
\&\fInbdkit\-cc\-plugin\fR\|(3),
\&\fInbdkit\-golang\-plugin\fR\|(3),
\&\fInbdkit\-lua\-plugin\fR\|(3),
\&\fInbdkit\-ocaml\-plugin\fR\|(3),
\&\fInbdkit\-perl\-plugin\fR\|(3),
\&\fInbdkit\-python\-plugin\fR\|(3),
\&\fInbdkit\-ruby\-plugin\fR\|(3),
\&\fInbdkit\-rust\-plugin\fR\|(3),
\&\fInbdkit\-sh\-plugin\fR\|(3),
\&\fInbdkit\-tcl\-plugin\fR\|(3)
\&.
.SS "\s-1API\s0 and \s-1ABI\s0 guarantee for C plugins"
.IX Subsection "API and ABI guarantee for C plugins"
Plugins written in C have an \s-1ABI\s0 guarantee: a plugin compiled against
an older version of nbdkit will still work correctly when loaded with
a newer nbdkit.  We also try (but cannot guarantee) to support plugins
compiled against a newer version of nbdkit when loaded with an older
nbdkit, although the plugin may have reduced functionality if it
depends on features only provided by newer nbdkit.
.PP
For plugins written in C, we also provide an \s-1API\s0 guarantee: a plugin
written against an older header will still compile unmodified with a
newer nbdkit.
.PP
The \s-1API\s0 guarantee does not always apply to plugins written in other
(non-C) languages which may have to adapt to changes when recompiled
against a newer nbdkit.
.SH "WRITING AN NBDKIT PLUGIN"
.IX Header "WRITING AN NBDKIT PLUGIN"
.ie n .SS """#define NBDKIT_API_VERSION 2"""
.el .SS "\f(CW#define NBDKIT_API_VERSION 2\fP"
.IX Subsection "#define NBDKIT_API_VERSION 2"
Plugins must choose which \s-1API\s0 version they want to use, by defining
\&\s-1NBDKIT_API_VERSION\s0 before including \f(CW\*(C`<nbdkit\-plugin.h>\*(C'\fR (or
any other nbdkit header).
.PP
If omitted, the default version is 1 for backwards-compatibility with
nbdkit v1.1.26 and earlier; however, it is recommended that new
plugins be written to the maximum version (currently 2) as it enables
more features and better interaction with nbdkit filters.
.PP
The rest of this document only covers the version 2 interface.  A
newer nbdkit will always support plugins written in C which use any
prior \s-1API\s0 version.
.ie n .SS """#include <nbdkit\-plugin.h>"""
.el .SS "\f(CW#include <nbdkit\-plugin.h>\fP"
.IX Subsection "#include <nbdkit-plugin.h>"
All plugins should start by including this header file (after
optionally choosing an \s-1API\s0 version).
.ie n .SS """#define THREAD_MODEL ..."""
.el .SS "\f(CW#define THREAD_MODEL ...\fP"
.IX Subsection "#define THREAD_MODEL ..."
All plugins must define a thread model.  See \*(L"Threads\*(R" below for
details.  It is generally safe to use:
.PP
.Vb 1
\& #define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_ALL_REQUESTS
.Ve
.ie n .SS """struct nbdkit_plugin"""
.el .SS "\f(CWstruct nbdkit_plugin\fP"
.IX Subsection "struct nbdkit_plugin"
All plugins must define and register one \f(CW\*(C`struct nbdkit_plugin\*(C'\fR,
which contains the name of the plugin and pointers to callback
functions, and use the \f(CW\*(C`NBDKIT_REGISTER_PLUGIN(plugin)\*(C'\fR macro:
.PP
.Vb 11
\& static struct nbdkit_plugin plugin = {
\&   .name              = "myplugin",
\&   .longname          = "My Plugin",
\&   .description       = "This is my great plugin for nbdkit",
\&   .open              = myplugin_open,
\&   .get_size          = myplugin_get_size,
\&   .pread             = myplugin_pread,
\&   .pwrite            = myplugin_pwrite,
\&   /* etc */
\& };
\& NBDKIT_REGISTER_PLUGIN(plugin)
.Ve
.PP
The \f(CW\*(C`.name\*(C'\fR field is the name of the plugin.
.PP
The callbacks are described below (see \*(L"\s-1CALLBACKS\*(R"\s0).  Only \f(CW\*(C`.name\*(C'\fR,
\&\f(CW\*(C`.open\*(C'\fR, \f(CW\*(C`.get_size\*(C'\fR and \f(CW\*(C`.pread\*(C'\fR are required.  All other
callbacks can be omitted, although typical plugins need to use more.
.SS "Callback lifecycle"
.IX Subsection "Callback lifecycle"
Callbacks are called in the following order over the lifecycle of
the plugin:
.PP
.Vb 10
\&         ┌──────────────────┐
\&         │ load             │
\&         └─────────┬────────┘
\&                   │           configuration phase starts     ─┐
\&         ┌─────────┴────────┐                                  ┆
\&         │ config           │  config is called once per       ┆
\&         └─────────┬────────┘↺ key=value on the command line   ┆
\&         ┌─────────┴────────┐                                  ┆
\&         │ config_complete  │                                  ┆
\&         └─────────┬────────┘                                  ┆
\&         ┌─────────┴────────┐                                  ┆
\&         │ thread_model     │                                  ┆
\&         └─────────┬────────┘  configuration phase ends       ─┘
\&         ┌─────────┴────────┐
\&         │ get_ready        │
\&         └─────────┬────────┘
\&                   │           nbdkit forks into the background
\&                   │           and starts serving clients
\&                   │
\&        ┌──────────┴─────────────┬─ ─ ─ ─ ─ ─ ─ ─ ─
\& ┌──────┴─────┐ client #1        │
\& │ preconnect │                  │
\& └──────┬─────┘                  │
\& ┌──────┴─────┐                  │
\& │ open       │                  │
\& └──────┬─────┘                  │
\& ┌──────┴─────┐  NBD option      │
\& │ can_write  │  negotiation     │
\& └──────┬─────┘                  │
\& ┌──────┴─────┐           ┌──────┴─────┐ client #2
\& │ get_size   │           │ preconnect │
\& └──────┬─────┘           └──────┬─────┘
\& ┌──────┴─────┐ data      ┌──────┴─────┐
\& │ pread      │ serving   │ open       │
\& └──────┬─────┘↺          └──────┬─────┘
\& ┌──────┴─────┐                 ...
\& │ pwrite     │
\& └──────┬─────┘↺          ┌──────┴─────┐
\& ┌──────┴─────┐           │ close      │
\& │ close      │           └────────────┘
\& └────────────┘
\& 
\&                   │           before nbdkit exits
\&                   │
\&         ┌─────────┴────────┐
\&         │ unload           │
\&         └──────────────────┘
.Ve
.ie n .IP """.load""" 4
.el .IP "\f(CW.load\fR" 4
.IX Item ".load"
is called once just after the plugin is loaded into memory.
.ie n .IP """.config"" and "".config_complete""" 4
.el .IP "\f(CW.config\fR and \f(CW.config_complete\fR" 4
.IX Item ".config and .config_complete"
\&\f(CW\*(C`.config\*(C'\fR is called zero or more times during command line parsing.
\&\f(CW\*(C`.config_complete\*(C'\fR is called once after all configuration information
has been passed to the plugin (but not during \f(CW\*(C`nbdkit \-\-dump\-plugin\*(C'\fR).
.Sp
Both are called after loading the plugin but before any connections
are accepted.
.ie n .IP """.thread_model""" 4
.el .IP "\f(CW.thread_model\fR" 4
.IX Item ".thread_model"
In normal operation, \f(CW\*(C`.thread_model\*(C'\fR is called once after
\&\f(CW\*(C`.config_complete\*(C'\fR has validated all configuration information, and
before any connections are accepted.  However, during \f(CW\*(C`nbdkit
\&\-\-dump\-plugin\*(C'\fR, it is called after any \f(CW\*(C`.config\*(C'\fR calls but without
\&\f(CW\*(C`.config_complete\*(C'\fR (so a plugin which determines the results from a
script must be prepared for a missing script).
.ie n .IP """.get_ready""" 4
.el .IP "\f(CW.get_ready\fR" 4
.IX Item ".get_ready"
In normal operation, \f(CW\*(C`.get_ready\*(C'\fR is called before the server starts
serving.  It is called before the server forks or changes directory.
It is the last chance to do any global preparation that is needed to
serve connections.
.ie n .IP """.preconnect""" 4
.el .IP "\f(CW.preconnect\fR" 4
.IX Item ".preconnect"
Called when a \s-1TCP\s0 connection has been made to the server.  This
happens early, before \s-1NBD\s0 or \s-1TLS\s0 negotiation.
.ie n .IP """.open""" 4
.el .IP "\f(CW.open\fR" 4
.IX Item ".open"
A new client has connected and finished the \s-1NBD\s0 handshake.  \s-1TLS\s0
negotiation (if required) has been completed successfully.
.ie n .IP """.can_write"", "".get_size"" and other option negotiation callbacks" 4
.el .IP "\f(CW.can_write\fR, \f(CW.get_size\fR and other option negotiation callbacks" 4
.IX Item ".can_write, .get_size and other option negotiation callbacks"
These are called during option negotiation with the client, but before
any data is served.  These callbacks may return different values
across different \f(CW\*(C`.open\*(C'\fR calls, but within a single connection, they
are called at most once and cached by nbdkit for that connection.
.ie n .IP """.pread"", "".pwrite"" and other data serving callbacks" 4
.el .IP "\f(CW.pread\fR, \f(CW.pwrite\fR and other data serving callbacks" 4
.IX Item ".pread, .pwrite and other data serving callbacks"
After option negotiation has finished, these may be called to serve
data.  Depending on the thread model chosen, they might be called in
parallel from multiple threads.  The data serving callbacks include a
flags argument; the results of the negotiation callbacks influence
whether particular flags will ever be passed to a data callback.
.ie n .IP """.close""" 4
.el .IP "\f(CW.close\fR" 4
.IX Item ".close"
The client has disconnected.
.ie n .IP """.preconnect"", "".open"" ... "".close""" 4
.el .IP "\f(CW.preconnect\fR, \f(CW.open\fR ... \f(CW.close\fR" 4
.IX Item ".preconnect, .open ... .close"
The sequence \f(CW\*(C`.preconnect\*(C'\fR, \f(CW\*(C`.open\*(C'\fR ... \f(CW\*(C`.close\*(C'\fR can be called
repeatedly over the lifetime of the plugin, and can be called in
parallel (depending on the thread model).
.ie n .IP """.unload""" 4
.el .IP "\f(CW.unload\fR" 4
.IX Item ".unload"
is called once just before the plugin is unloaded from memory.
.SS "Flags"
.IX Subsection "Flags"
The following flags are defined by nbdkit, and used in various data
serving callbacks as follows:
.ie n .IP """NBDKIT_FLAG_MAY_TRIM""" 4
.el .IP "\f(CWNBDKIT_FLAG_MAY_TRIM\fR" 4
.IX Item "NBDKIT_FLAG_MAY_TRIM"
This flag is used by the \f(CW\*(C`.zero\*(C'\fR callback; there is no way to disable
this flag, although a plugin that does not support trims as a way to
write zeroes may ignore the flag without violating expected semantics.
.ie n .IP """NBDKIT_FLAG_FUA""" 4
.el .IP "\f(CWNBDKIT_FLAG_FUA\fR" 4
.IX Item "NBDKIT_FLAG_FUA"
This flag represents Forced Unit Access semantics.  It is used by the
\&\f(CW\*(C`.pwrite\*(C'\fR, \f(CW\*(C`.zero\*(C'\fR, and \f(CW\*(C`.trim\*(C'\fR callbacks to indicate that the
plugin must not return a result until the action has landed in
persistent storage.  This flag will not be sent to the plugin unless
\&\f(CW\*(C`.can_fua\*(C'\fR is provided and returns \f(CW\*(C`NBDKIT_FUA_NATIVE\*(C'\fR.
.PP
The following defines are valid as successful return values for
\&\f(CW\*(C`.can_fua\*(C'\fR:
.ie n .IP """NBDKIT_FUA_NONE""" 4
.el .IP "\f(CWNBDKIT_FUA_NONE\fR" 4
.IX Item "NBDKIT_FUA_NONE"
Forced Unit Access is not supported; the client must manually request
a flush after writes have completed.  The \f(CW\*(C`NBDKIT_FLAG_FUA\*(C'\fR flag will
not be passed to the plugin's write callbacks.
.ie n .IP """NBDKIT_FUA_EMULATE""" 4
.el .IP "\f(CWNBDKIT_FUA_EMULATE\fR" 4
.IX Item "NBDKIT_FUA_EMULATE"
The client may request Forced Unit Access, but it is implemented by
emulation, where nbdkit calls \f(CW\*(C`.flush\*(C'\fR after a write operation; this
is semantically correct, but may hurt performance as it tends to flush
more data than just what the client requested.  The \f(CW\*(C`NBDKIT_FLAG_FUA\*(C'\fR
flag will not be passed to the plugin's write callbacks.
.ie n .IP """NBDKIT_FUA_NATIVE""" 4
.el .IP "\f(CWNBDKIT_FUA_NATIVE\fR" 4
.IX Item "NBDKIT_FUA_NATIVE"
The client may request Forced Unit Access, which results in the
\&\f(CW\*(C`NBDKIT_FLAG_FUA\*(C'\fR flag being passed to the plugin's write callbacks
(\f(CW\*(C`.pwrite\*(C'\fR, \f(CW\*(C`.trim\*(C'\fR, and \f(CW\*(C`.zero\*(C'\fR).  When the flag is set, these
callbacks must not return success until the client's request has
landed in persistent storage.
.PP
The following defines are valid as successful return values for
\&\f(CW\*(C`.can_cache\*(C'\fR:
.ie n .IP """NBDKIT_CACHE_NONE""" 4
.el .IP "\f(CWNBDKIT_CACHE_NONE\fR" 4
.IX Item "NBDKIT_CACHE_NONE"
The server does not advertise caching support, and rejects any
client-requested caching. Any \f(CW\*(C`.cache\*(C'\fR callback is ignored.
.ie n .IP """NBDKIT_CACHE_EMULATE""" 4
.el .IP "\f(CWNBDKIT_CACHE_EMULATE\fR" 4
.IX Item "NBDKIT_CACHE_EMULATE"
The nbdkit server advertises cache support to the client, where the
client may request that the server cache a region of the export to
potentially speed up future read and/or write operations on that
region. The nbdkit server implements the caching by calling \f(CW\*(C`.pread\*(C'\fR
and ignoring the results. This option exists to ease the
implementation of a common form of caching; any \f(CW\*(C`.cache\*(C'\fR callback is
ignored.
.ie n .IP """NBDKIT_CACHE_NATIVE""" 4
.el .IP "\f(CWNBDKIT_CACHE_NATIVE\fR" 4
.IX Item "NBDKIT_CACHE_NATIVE"
The nbdkit server advertises cache support to the client, where the
client may request that the server cache a region of the export to
potentially speed up future read and/or write operations on that
region. The nbdkit server calls the \f(CW\*(C`.cache\*(C'\fR callback to perform the
caching; if that callback is missing, the client's cache request
succeeds without doing anything.
.SS "Threads"
.IX Subsection "Threads"
Each nbdkit plugin must declare its maximum thread safety model by
defining the \f(CW\*(C`THREAD_MODEL\*(C'\fR macro.  (This macro is used by
\&\f(CW\*(C`NBDKIT_REGISTER_PLUGIN\*(C'\fR).  Additionally, a plugin may implement the
\&\f(CW\*(C`.thread_model\*(C'\fR callback, called right after \f(CW\*(C`.config_complete\*(C'\fR to
make a runtime decision on which thread model to use.  The nbdkit
server chooses the most restrictive model between the plugin's
\&\f(CW\*(C`THREAD_MODEL\*(C'\fR, the \f(CW\*(C`.thread_model\*(C'\fR if present, any restrictions
requested by filters, and any limitations imposed by the operating
system.
.PP
In \f(CW\*(C`nbdkit \-\-dump\-plugin PLUGIN\*(C'\fR output, the \f(CW\*(C`max_thread_model\*(C'\fR line
matches the \f(CW\*(C`THREAD_MODEL\*(C'\fR macro, and the \f(CW\*(C`thread_model\*(C'\fR line
matches what the system finally settled on after applying all
restrictions.
.PP
The possible settings for \f(CW\*(C`THREAD_MODEL\*(C'\fR are defined below.
.ie n .IP """#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_CONNECTIONS""" 4
.el .IP "\f(CW#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_CONNECTIONS\fR" 4
.IX Item "#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_CONNECTIONS"
Only a single handle can be open at any time, and all requests happen
from one thread.
.Sp
Note this means only one client can connect to the server at any time.
If a second client tries to connect it will block waiting for the
first client to close the connection.
.ie n .IP """#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_ALL_REQUESTS""" 4
.el .IP "\f(CW#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_ALL_REQUESTS\fR" 4
.IX Item "#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_ALL_REQUESTS"
\&\fIThis is a safe default for most plugins\fR.
.Sp
Multiple handles can be open at the same time, but requests are
serialized so that for the plugin as a whole only one
open/read/write/close (etc) request will be in progress at any time.
.Sp
This is a useful setting if the library you are using is not
thread-safe.  However performance may not be good.
.ie n .IP """#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_REQUESTS""" 4
.el .IP "\f(CW#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_REQUESTS\fR" 4
.IX Item "#define THREAD_MODEL NBDKIT_THREAD_MODEL_SERIALIZE_REQUESTS"
Multiple handles can be open and multiple data requests can happen in
parallel.  However only one request will happen per handle at a time
(but requests on different handles might happen concurrently).
.ie n .IP """#define THREAD_MODEL NBDKIT_THREAD_MODEL_PARALLEL""" 4
.el .IP "\f(CW#define THREAD_MODEL NBDKIT_THREAD_MODEL_PARALLEL\fR" 4
.IX Item "#define THREAD_MODEL NBDKIT_THREAD_MODEL_PARALLEL"
Multiple handles can be open and multiple data requests can happen in
parallel (even on the same handle).  The server may reorder replies,
answering a later request before an earlier one.
.Sp
All the libraries you use must be thread-safe and reentrant, and any
code that creates a file descriptor should atomically set
\&\f(CW\*(C`FD_CLOEXEC\*(C'\fR if you do not want it accidentally leaked to another
thread's child process.  You may also need to provide mutexes for
fields in your connection handle.
.PP
If none of the above thread models are suitable, use
\&\f(CW\*(C`NBDKIT_THREAD_MODEL_PARALLEL\*(C'\fR and implement your own locking using
\&\f(CW\*(C`pthread_mutex_t\*(C'\fR etc.
.SS "Error handling"
.IX Subsection "Error handling"
If there is an error in the plugin, the plugin should call
\&\f(CW\*(C`nbdkit_error\*(C'\fR to report an error message; additionally, if the
callback is involved in serving data, the plugin should call
\&\f(CW\*(C`nbdkit_set_error\*(C'\fR to influence the error code that will be sent to
the client.  These two functions can be called in either order.  Then,
the callback should return the appropriate error indication,
eg. \f(CW\*(C`NULL\*(C'\fR or \f(CW\*(C`\-1\*(C'\fR.
.PP
If the call to \f(CW\*(C`nbdkit_set_error\*(C'\fR is omitted while serving data, then
the global variable \f(CW\*(C`errno\*(C'\fR may be used.  For plugins which have
\&\f(CW\*(C`.errno_is_preserved != 0\*(C'\fR the core code will use \f(CW\*(C`errno\*(C'\fR.  In
plugins written in non-C languages, we usually cannot trust that
\&\f(CW\*(C`errno\*(C'\fR will not be overwritten when returning from that language to
C.  In that case, either the plugin must call \f(CW\*(C`nbdkit_set_error\*(C'\fR or
hard-coded \f(CW\*(C`EIO\*(C'\fR is used.
.PP
\&\f(CW\*(C`nbdkit_error\*(C'\fR has the following prototype and works like
\&\fIprintf\fR\|(3):
.PP
.Vb 2
\& void nbdkit_error (const char *fs, ...);
\& void nbdkit_verror (const char *fs, va_list args);
.Ve
.PP
For convenience, \f(CW\*(C`nbdkit_error\*(C'\fR preserves the value of \f(CW\*(C`errno\*(C'\fR, and
also supports the glibc extension of a single \f(CW%m\fR in a format string
expanding to \f(CW\*(C`strerror(errno)\*(C'\fR, even on platforms that don't support
that natively.
.PP
\&\f(CW\*(C`nbdkit_set_error\*(C'\fR can be called at any time, but only has an impact
during callbacks for serving data, and only when the callback returns
an indication of failure.  It has the following prototype:
.PP
.Vb 1
\& void nbdkit_set_error (int err);
.Ve
.SH "CALLBACKS"
.IX Header "CALLBACKS"
.ie n .SS """.name"""
.el .SS "\f(CW.name\fP"
.IX Subsection ".name"
.Vb 1
\& const char *name;
.Ve
.PP
This field (a string) is required, and \fBmust\fR contain only \s-1ASCII\s0
alphanumeric characters and be unique amongst all plugins.
.ie n .SS """.version"""
.el .SS "\f(CW.version\fP"
.IX Subsection ".version"
.Vb 1
\& const char *version;
.Ve
.PP
Plugins may optionally set a version string which is displayed in help
and debugging output.
.ie n .SS """.longname"""
.el .SS "\f(CW.longname\fP"
.IX Subsection ".longname"
.Vb 1
\& const char *longname;
.Ve
.PP
An optional free text name of the plugin.  This field is used in error
messages.
.ie n .SS """.description"""
.el .SS "\f(CW.description\fP"
.IX Subsection ".description"
.Vb 1
\& const char *description;
.Ve
.PP
An optional multi-line description of the plugin.
.ie n .SS """.load"""
.el .SS "\f(CW.load\fP"
.IX Subsection ".load"
.Vb 1
\& void load (void);
.Ve
.PP
This is called once just after the plugin is loaded into memory.  You
can use this to perform any global initialization needed by the
plugin.
.ie n .SS """.unload"""
.el .SS "\f(CW.unload\fP"
.IX Subsection ".unload"
.Vb 1
\& void unload (void);
.Ve
.PP
This may be called once just before the plugin is unloaded from
memory.  Note that it's not guaranteed that \f(CW\*(C`.unload\*(C'\fR will always be
called (eg. the server might be killed or segfault), so you should try
to make the plugin as robust as possible by not requiring cleanup.
See also \*(L"\s-1SHUTDOWN\*(R"\s0 below.
.ie n .SS """.dump_plugin"""
.el .SS "\f(CW.dump_plugin\fP"
.IX Subsection ".dump_plugin"
.Vb 1
\& void dump_plugin (void);
.Ve
.PP
This optional callback is called when the
\&\f(CW\*(C`nbdkit plugin \-\-dump\-plugin\*(C'\fR command is used.  It should print
any additional informative \f(CW\*(C`key=value\*(C'\fR fields to stdout as needed.
Prefixing the keys with the name of the plugin will avoid conflicts.
.ie n .SS """.config"""
.el .SS "\f(CW.config\fP"
.IX Subsection ".config"
.Vb 1
\& int config (const char *key, const char *value);
.Ve
.PP
On the nbdkit command line, after the plugin filename, come an
optional list of \f(CW\*(C`key=value\*(C'\fR arguments.  These are passed to the
plugin through this callback when the plugin is first loaded and
before any connections are accepted.
.PP
This callback may be called zero or more times.
.PP
Both \f(CW\*(C`key\*(C'\fR and \f(CW\*(C`value\*(C'\fR parameters will be non-NULL.  The strings are
owned by nbdkit but will remain valid for the lifetime of the plugin,
so the plugin does not need to copy them.
.PP
The key will be a non-empty string beginning with an \s-1ASCII\s0 alphabetic
character (\f(CW\*(C`A\-Z\*(C'\fR \f(CW\*(C`a\-z\*(C'\fR).  The rest of the key must contain only
\&\s-1ASCII\s0 alphanumeric plus period, underscore or dash characters (\f(CW\*(C`A\-Z\*(C'\fR
\&\f(CW\*(C`a\-z\*(C'\fR \f(CW\*(C`0\-9\*(C'\fR \f(CW\*(C`.\*(C'\fR \f(CW\*(C`_\*(C'\fR \f(CW\*(C`\-\*(C'\fR).  The value may be an arbitrary string,
including an empty string.
.PP
The names of \f(CW\*(C`key\*(C'\fRs accepted by plugins is up to the plugin, but you
should probably look at other plugins and follow the same conventions.
.PP
If the value is a relative path, then note that the server changes
directory when it starts up.  See \*(L"\s-1FILENAMES AND PATHS\*(R"\s0 above.
.PP
If \f(CW\*(C`nbdkit_stdio_safe\*(C'\fR returns 1, the value of the configuration
parameter may be used to trigger reading additional data through stdin
(such as a password or inline script).
.PP
If the \f(CW\*(C`.config\*(C'\fR callback is not provided by the plugin, and the user
tries to specify any \f(CW\*(C`key=value\*(C'\fR arguments, then nbdkit will exit
with an error.
.PP
If there is an error, \f(CW\*(C`.config\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an
error message and return \f(CW\*(C`\-1\*(C'\fR.
.ie n .SS """.magic_config_key"""
.el .SS "\f(CW.magic_config_key\fP"
.IX Subsection ".magic_config_key"
.Vb 1
\& const char *magic_config_key;
.Ve
.PP
This optional string can be used to set a \*(L"magic\*(R" key used when
parsing plugin parameters.  It affects how \*(L"bare parameters\*(R" (those
which do not contain an \f(CW\*(C`=\*(C'\fR character) are parsed on the command
line.
.PP
If \f(CW\*(C`magic_config_key != NULL\*(C'\fR then any bare parameters are passed to
the \f(CW\*(C`.config\*(C'\fR method as: \f(CW\*(C`config (magic_config_key, argv[i]);\*(C'\fR.
.PP
If \f(CW\*(C`magic_config_key\*(C'\fR is not set then we behave as in nbdkit <
1.7: If the first parameter on the command line is bare then it is
passed to the \f(CW\*(C`.config\*(C'\fR method as: \f(CW\*(C`config ("script", value);\*(C'\fR.
Any other bare parameters give errors.
.ie n .SS """.config_complete"""
.el .SS "\f(CW.config_complete\fP"
.IX Subsection ".config_complete"
.Vb 1
\& int config_complete (void);
.Ve
.PP
This optional callback is called after all the configuration has been
passed to the plugin.  It is a good place to do checks, for example
that the user has passed the required parameters to the plugin.
.PP
If there is an error, \f(CW\*(C`.config_complete\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR
with an error message and return \f(CW\*(C`\-1\*(C'\fR.
.ie n .SS """.config_help"""
.el .SS "\f(CW.config_help\fP"
.IX Subsection ".config_help"
.Vb 1
\& const char *config_help;
.Ve
.PP
This optional multi-line help message should summarize any
\&\f(CW\*(C`key=value\*(C'\fR parameters that it takes.  It does \fInot\fR need to repeat
what already appears in \f(CW\*(C`.description\*(C'\fR.
.PP
If the plugin doesn't take any config parameters you should probably
omit this.
.ie n .SS """.thread_model"""
.el .SS "\f(CW.thread_model\fP"
.IX Subsection ".thread_model"
.Vb 1
\& int thread_model (void)
.Ve
.PP
This optional callback is called after all the configuration has been
passed to the plugin.  It can be used to force a stricter thread model
based on configuration, compared to \f(CW\*(C`THREAD_MODEL\*(C'\fR.  See \*(L"Threads\*(R"
above for details.  Attempts to request a looser (more parallel) model
are silently ignored.
.PP
If there is an error, \f(CW\*(C`.thread_model\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR
with an error message and return \f(CW\*(C`\-1\*(C'\fR.
.ie n .SS """.get_ready"""
.el .SS "\f(CW.get_ready\fP"
.IX Subsection ".get_ready"
.Vb 1
\& int get_ready (void);
.Ve
.PP
This optional callback is called before the server starts serving.  It
is called before the server forks or changes directory.  It is the
last chance to do any global preparation that is needed to serve
connections.
.PP
If there is an error, \f(CW\*(C`.get_ready\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with
an error message and return \f(CW\*(C`\-1\*(C'\fR.
.ie n .SS """.preconnect"""
.el .SS "\f(CW.preconnect\fP"
.IX Subsection ".preconnect"
.Vb 1
\& int preconnect (int readonly);
.Ve
.PP
This optional callback is called when a \s-1TCP\s0 connection has been made
to the server.  This happens early, before \s-1NBD\s0 or \s-1TLS\s0 negotiation.  If
\&\s-1TLS\s0 authentication is required to access the server, then it has
\&\fBnot\fR been negotiated at this point.
.PP
For security reasons (to avoid denial of service attacks) this
callback should be written to be as fast and take as few resources as
possible.  If you use this callback, only use it to do basic access
control, such as checking \f(CW\*(C`nbdkit_peer_name\*(C'\fR against a whitelist (see
\&\*(L"\s-1PEER NAME\*(R"\s0 and \fInbdkit\-ip\-filter\fR\|(1)).  It may be better to do
access control outside the server, for example using \s-1TCP\s0 wrappers or a
firewall.
.PP
The \f(CW\*(C`readonly\*(C'\fR flag informs the plugin that the server was started
with the \fI\-r\fR flag on the command line.
.PP
Returning \f(CW0\fR will allow the connection to continue.  If there is an
error or you want to deny the connection, call \f(CW\*(C`nbdkit_error\*(C'\fR with an
error message and return \f(CW\*(C`\-1\*(C'\fR.
.ie n .SS """.open"""
.el .SS "\f(CW.open\fP"
.IX Subsection ".open"
.Vb 1
\& void *open (int readonly);
.Ve
.PP
This is called when a new client connects to the nbdkit server.  The
callback should allocate a handle and return it.  This handle
is passed back to other callbacks and could be freed in the \f(CW\*(C`.close\*(C'\fR
callback.
.PP
Note that the handle is completely opaque to nbdkit, but it must not
be \s-1NULL.\s0  If you don't need to use a handle, return
\&\f(CW\*(C`NBDKIT_HANDLE_NOT_NEEDED\*(C'\fR which is a static non-NULL pointer.
.PP
The \f(CW\*(C`readonly\*(C'\fR flag informs the plugin that the server was started
with the \fI\-r\fR flag on the command line which forces connections to be
read-only.  Note that the plugin may \fIadditionally\fR force the
connection to be readonly (even if this flag is false) by returning
false from the \f(CW\*(C`.can_write\*(C'\fR callback.  So if your plugin can only
serve read-only, you can ignore this parameter.
.PP
This callback is called after the \s-1NBD\s0 handshake has completed, which
includes \s-1TLS\s0 authentication (if required).  If the plugin defines a
\&\f(CW\*(C`.preconnect\*(C'\fR callback, then it must be called and return with
success before \f(CW\*(C`.open\*(C'\fR is called.
.PP
If there is an error, \f(CW\*(C`.open\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an
error message and return \f(CW\*(C`NULL\*(C'\fR.
.ie n .SS """.close"""
.el .SS "\f(CW.close\fP"
.IX Subsection ".close"
.Vb 1
\& void close (void *handle);
.Ve
.PP
This is called when the client closes the connection.  It should clean
up any per-connection resources.
.PP
Note there is no way in the \s-1NBD\s0 protocol to communicate close errors
back to the client, for example if your plugin calls \fIclose\fR\|(2) and
you are checking for errors (as you should do).  Therefore the best
you can do is to log the error on the server.  Well-behaved \s-1NBD\s0
clients \fIshould\fR try to flush the connection before it is closed and
check for errors, but obviously this is outside the scope of nbdkit.
.ie n .SS """.get_size"""
.el .SS "\f(CW.get_size\fP"
.IX Subsection ".get_size"
.Vb 1
\& int64_t get_size (void *handle);
.Ve
.PP
This is called during the option negotiation phase of the protocol
to get the size (in bytes) of the block device being exported.
.PP
The returned size must be ≥ 0.  If there is an error, \f(CW\*(C`.get_size\*(C'\fR
should call \f(CW\*(C`nbdkit_error\*(C'\fR with an error message and return \f(CW\*(C`\-1\*(C'\fR.
.ie n .SS """.can_write"""
.el .SS "\f(CW.can_write\fP"
.IX Subsection ".can_write"
.Vb 1
\& int can_write (void *handle);
.Ve
.PP
This is called during the option negotiation phase to find out if the
handle supports writes.
.PP
If there is an error, \f(CW\*(C`.can_write\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with
an error message and return \f(CW\*(C`\-1\*(C'\fR.
.PP
This callback is not required.  If omitted, then we return true iff a
\&\f(CW\*(C`.pwrite\*(C'\fR callback has been defined.
.ie n .SS """.can_flush"""
.el .SS "\f(CW.can_flush\fP"
.IX Subsection ".can_flush"
.Vb 1
\& int can_flush (void *handle);
.Ve
.PP
This is called during the option negotiation phase to find out if the
handle supports the flush-to-disk operation.
.PP
If there is an error, \f(CW\*(C`.can_flush\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with
an error message and return \f(CW\*(C`\-1\*(C'\fR.
.PP
This callback is not required.  If omitted, then we return true iff a
\&\f(CW\*(C`.flush\*(C'\fR callback has been defined.
.ie n .SS """.is_rotational"""
.el .SS "\f(CW.is_rotational\fP"
.IX Subsection ".is_rotational"
.Vb 1
\& int is_rotational (void *handle);
.Ve
.PP
This is called during the option negotiation phase to find out if the
backing disk is a rotational medium (like a traditional hard disk) or
not (like an \s-1SSD\s0).  If true, this may cause the client to reorder
requests to make them more efficient for a slow rotating disk.
.PP
If there is an error, \f(CW\*(C`.is_rotational\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR
with an error message and return \f(CW\*(C`\-1\*(C'\fR.
.PP
This callback is not required.  If omitted, then we return false.
.ie n .SS """.can_trim"""
.el .SS "\f(CW.can_trim\fP"
.IX Subsection ".can_trim"
.Vb 1
\& int can_trim (void *handle);
.Ve
.PP
This is called during the option negotiation phase to find out if the
plugin supports the trim/discard operation for punching holes in the
backing storage.
.PP
If there is an error, \f(CW\*(C`.can_trim\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an
error message and return \f(CW\*(C`\-1\*(C'\fR.
.PP
This callback is not required.  If omitted, then we return true iff a
\&\f(CW\*(C`.trim\*(C'\fR callback has been defined.
.ie n .SS """.can_zero"""
.el .SS "\f(CW.can_zero\fP"
.IX Subsection ".can_zero"
.Vb 1
\& int can_zero (void *handle);
.Ve
.PP
This is called during the option negotiation phase to find out if the
plugin wants the \f(CW\*(C`.zero\*(C'\fR callback to be utilized.  Support for
writing zeroes is still advertised to the client (unless the
\&\fInbdkit\-nozero\-filter\fR\|(1) is also used), so returning false merely
serves as a way to avoid complicating the \f(CW\*(C`.zero\*(C'\fR callback to have to
fail with \f(CW\*(C`ENOTSUP\*(C'\fR or \f(CW\*(C`EOPNOTSUPP\*(C'\fR on the connections where it will
never be more efficient than using \f(CW\*(C`.pwrite\*(C'\fR up front.
.PP
If there is an error, \f(CW\*(C`.can_zero\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an
error message and return \f(CW\*(C`\-1\*(C'\fR.
.PP
This callback is not required.  If omitted, then for a normal zero
request, nbdkit always tries \f(CW\*(C`.zero\*(C'\fR first if it is present, and
gracefully falls back to \f(CW\*(C`.pwrite\*(C'\fR if \f(CW\*(C`.zero\*(C'\fR was absent or failed
with \f(CW\*(C`ENOTSUP\*(C'\fR or \f(CW\*(C`EOPNOTSUPP\*(C'\fR.
.ie n .SS """.can_fast_zero"""
.el .SS "\f(CW.can_fast_zero\fP"
.IX Subsection ".can_fast_zero"
.Vb 1
\& int can_fast_zero (void *handle);
.Ve
.PP
This is called during the option negotiation phase to find out if the
plugin wants to advertise support for fast zero requests.  If this
support is not advertised, a client cannot attempt fast zero requests,
and has no way to tell if writing zeroes offers any speedups compared
to using \f(CW\*(C`.pwrite\*(C'\fR (other than compressed network traffic).  If
support is advertised, then \f(CW\*(C`.zero\*(C'\fR will have
\&\f(CW\*(C`NBDKIT_FLAG_FAST_ZERO\*(C'\fR set when the client has requested a fast
zero, in which case the plugin must fail with \f(CW\*(C`ENOTSUP\*(C'\fR or
\&\f(CW\*(C`EOPNOTSUPP\*(C'\fR up front if the request would not offer any benefits
over \f(CW\*(C`.pwrite\*(C'\fR.  Advertising support for fast zero requests does not
require that writing zeroes be fast, only that the result (whether
success or failure) is fast, so this should be advertised when
feasible.
.PP
If there is an error, \f(CW\*(C`.can_fast_zero\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR
with an error message and return \f(CW\*(C`\-1\*(C'\fR.
.PP
This callback is not required.  If omitted, then nbdkit returns true
if \f(CW\*(C`.zero\*(C'\fR is absent or \f(CW\*(C`.can_zero\*(C'\fR returns false (in those cases,
nbdkit fails all fast zero requests, as its fallback to \f(CW\*(C`.pwrite\*(C'\fR is
not inherently faster), otherwise false (since it cannot be determined
in advance if the plugin's \f(CW\*(C`.zero\*(C'\fR will properly honor the semantics
of \f(CW\*(C`NBDKIT_FLAG_FAST_ZERO\*(C'\fR).
.ie n .SS """.can_extents"""
.el .SS "\f(CW.can_extents\fP"
.IX Subsection ".can_extents"
.Vb 1
\& int can_extents (void *handle);
.Ve
.PP
This is called during the option negotiation phase to find out if the
plugin supports detecting allocated (non-sparse) regions of the disk
with the \f(CW\*(C`.extents\*(C'\fR callback.
.PP
If there is an error, \f(CW\*(C`.can_extents\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with
an error message and return \f(CW\*(C`\-1\*(C'\fR.
.PP
This callback is not required.  If omitted, then we return true iff a
\&\f(CW\*(C`.extents\*(C'\fR callback has been defined.
.ie n .SS """.can_fua"""
.el .SS "\f(CW.can_fua\fP"
.IX Subsection ".can_fua"
.Vb 1
\& int can_fua (void *handle);
.Ve
.PP
This is called during the option negotiation phase to find out if the
plugin supports the Forced Unit Access (\s-1FUA\s0) flag on write, zero, and
trim requests.  If this returns \f(CW\*(C`NBDKIT_FUA_NONE\*(C'\fR, \s-1FUA\s0 support is not
advertised to the client; if this returns \f(CW\*(C`NBDKIT_FUA_EMULATE\*(C'\fR, the
\&\f(CW\*(C`.flush\*(C'\fR callback must work (even if \f(CW\*(C`.can_flush\*(C'\fR returns false),
and \s-1FUA\s0 support is emulated by calling \f(CW\*(C`.flush\*(C'\fR after any write
operation; if this returns \f(CW\*(C`NBDKIT_FUA_NATIVE\*(C'\fR, then the \f(CW\*(C`.pwrite\*(C'\fR,
\&\f(CW\*(C`.zero\*(C'\fR, and \f(CW\*(C`.trim\*(C'\fR callbacks (if implemented) must handle the flag
\&\f(CW\*(C`NBDKIT_FLAG_FUA\*(C'\fR, by not returning until that action has landed in
persistent storage.
.PP
If there is an error, \f(CW\*(C`.can_fua\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an
error message and return \f(CW\*(C`\-1\*(C'\fR.
.PP
This callback is not required unless a plugin wants to specifically
handle \s-1FUA\s0 requests.  If omitted, nbdkit checks whether \f(CW\*(C`.flush\*(C'\fR
exists, and behaves as if this function returns \f(CW\*(C`NBDKIT_FUA_NONE\*(C'\fR or
\&\f(CW\*(C`NBDKIT_FUA_EMULATE\*(C'\fR as appropriate.
.ie n .SS """.can_multi_conn"""
.el .SS "\f(CW.can_multi_conn\fP"
.IX Subsection ".can_multi_conn"
.Vb 1
\& int can_multi_conn (void *handle);
.Ve
.PP
This is called during the option negotiation phase to find out if the
plugin is prepared to handle multiple connections from a single
client.  If the plugin sets this to true then a client may try to open
multiple connections to the nbdkit server and spread requests across
all connections to maximize parallelism.  If the plugin sets it to
false (which is the default) then well-behaved clients should only
open a single connection, although we cannot control what clients do
in practice.
.PP
Specifically it means that either the plugin does not cache requests
at all.  Or if it does cache them then the effects of a \f(CW\*(C`.flush\*(C'\fR
request or setting \f(CW\*(C`NBDKIT_FLAG_FUA\*(C'\fR on a request must be visible
across all connections to the plugin before the plugin replies to that
request.
.PP
Properly working clients should send the same export name for each of
these connections.
.PP
If you use Linux \fInbd\-client\fR\|(8) option \fI\-C num\fR with
num > 1 then Linux checks this flag and will refuse to connect
if \f(CW\*(C`.can_multi_conn\*(C'\fR is false.
.PP
If there is an error, \f(CW\*(C`.can_multi_conn\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR
with an error message and return \f(CW\*(C`\-1\*(C'\fR.
.PP
This callback is not required.  If omitted, then we return false.
.ie n .SS """.can_cache"""
.el .SS "\f(CW.can_cache\fP"
.IX Subsection ".can_cache"
.Vb 1
\& int can_cache (void *handle);
.Ve
.PP
This is called during the option negotiation phase to find out if the
plugin supports a cache operation. The nature of the caching is
unspecified (including whether there are limits on how much can be
cached at once, and whether writes to a cached region have
write-through or write-back semantics), but the command exists to let
clients issue a hint to the server that they will be accessing that
region of the export.
.PP
If this returns \f(CW\*(C`NBDKIT_CACHE_NONE\*(C'\fR, cache support is not advertised
to the client; if this returns \f(CW\*(C`NBDKIT_CACHE_EMULATE\*(C'\fR, caching is
emulated by the server calling \f(CW\*(C`.pread\*(C'\fR and ignoring the results; if
this returns \f(CW\*(C`NBDKIT_CACHE_NATIVE\*(C'\fR, then the \f(CW\*(C`.cache\*(C'\fR callback will
be used.  If there is an error, \f(CW\*(C`.can_cache\*(C'\fR should call
\&\f(CW\*(C`nbdkit_error\*(C'\fR with an error message and return \f(CW\*(C`\-1\*(C'\fR.
.PP
This callback is not required.  If omitted, then we return
\&\f(CW\*(C`NBDKIT_CACHE_NONE\*(C'\fR if the \f(CW\*(C`.cache\*(C'\fR callback is missing, or
\&\f(CW\*(C`NBDKIT_CACHE_NATIVE\*(C'\fR if it is defined.
.ie n .SS """.pread"""
.el .SS "\f(CW.pread\fP"
.IX Subsection ".pread"
.Vb 2
\& int pread (void *handle, void *buf, uint32_t count, uint64_t offset,
\&            uint32_t flags);
.Ve
.PP
During the data serving phase, nbdkit calls this callback to read data
from the backing store.  \f(CW\*(C`count\*(C'\fR bytes starting at \f(CW\*(C`offset\*(C'\fR in the
backing store should be read and copied into \f(CW\*(C`buf\*(C'\fR.  nbdkit takes
care of all bounds\- and sanity-checking, so the plugin does not need
to worry about that.
.PP
The parameter \f(CW\*(C`flags\*(C'\fR exists in case of future \s-1NBD\s0 protocol
extensions; at this time, it will be 0 on input.
.PP
The callback must read the whole \f(CW\*(C`count\*(C'\fR bytes if it can.  The \s-1NBD\s0
protocol doesn't allow partial reads (instead, these would be errors).
If the whole \f(CW\*(C`count\*(C'\fR bytes was read, the callback should return \f(CW0\fR
to indicate there was \fIno\fR error.
.PP
If there is an error (including a short read which couldn't be
recovered from), \f(CW\*(C`.pread\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an error
message, and \f(CW\*(C`nbdkit_set_error\*(C'\fR to record an appropriate error
(unless \f(CW\*(C`errno\*(C'\fR is sufficient), then return \f(CW\*(C`\-1\*(C'\fR.
.ie n .SS """.pwrite"""
.el .SS "\f(CW.pwrite\fP"
.IX Subsection ".pwrite"
.Vb 2
\& int pwrite (void *handle, const void *buf, uint32_t count, uint64_t offset,
\&             uint32_t flags);
.Ve
.PP
During the data serving phase, nbdkit calls this callback to write
data to the backing store.  \f(CW\*(C`count\*(C'\fR bytes starting at \f(CW\*(C`offset\*(C'\fR in
the backing store should be written using the data in \f(CW\*(C`buf\*(C'\fR.  nbdkit
takes care of all bounds\- and sanity-checking, so the plugin does not
need to worry about that.
.PP
This function will not be called if \f(CW\*(C`.can_write\*(C'\fR returned false.  The
parameter \f(CW\*(C`flags\*(C'\fR may include \f(CW\*(C`NBDKIT_FLAG_FUA\*(C'\fR on input based on
the result of \f(CW\*(C`.can_fua\*(C'\fR.
.PP
The callback must write the whole \f(CW\*(C`count\*(C'\fR bytes if it can.  The \s-1NBD\s0
protocol doesn't allow partial writes (instead, these would be
errors).  If the whole \f(CW\*(C`count\*(C'\fR bytes was written successfully, the
callback should return \f(CW0\fR to indicate there was \fIno\fR error.
.PP
If there is an error (including a short write which couldn't be
recovered from), \f(CW\*(C`.pwrite\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an error
message, and \f(CW\*(C`nbdkit_set_error\*(C'\fR to record an appropriate error
(unless \f(CW\*(C`errno\*(C'\fR is sufficient), then return \f(CW\*(C`\-1\*(C'\fR.
.ie n .SS """.flush"""
.el .SS "\f(CW.flush\fP"
.IX Subsection ".flush"
.Vb 1
\& int flush (void *handle, uint32_t flags);
.Ve
.PP
During the data serving phase, this callback is used to
\&\fIfdatasync\fR\|(2) the backing store, ie. to ensure it has been
completely written to a permanent medium.  If that is not possible
then you can omit this callback.
.PP
This function will not be called directly by the client if
\&\f(CW\*(C`.can_flush\*(C'\fR returned false; however, it may still be called by
nbdkit if \f(CW\*(C`.can_fua\*(C'\fR returned \f(CW\*(C`NBDKIT_FUA_EMULATE\*(C'\fR.  The parameter
\&\f(CW\*(C`flags\*(C'\fR exists in case of future \s-1NBD\s0 protocol extensions; at this
time, it will be 0 on input.
.PP
If there is an error, \f(CW\*(C`.flush\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an
error message, and \f(CW\*(C`nbdkit_set_error\*(C'\fR to record an appropriate error
(unless \f(CW\*(C`errno\*(C'\fR is sufficient), then return \f(CW\*(C`\-1\*(C'\fR.
.ie n .SS """.trim"""
.el .SS "\f(CW.trim\fP"
.IX Subsection ".trim"
.Vb 1
\& int trim (void *handle, uint32_t count, uint64_t offset, uint32_t flags);
.Ve
.PP
During the data serving phase, this callback is used to \*(L"punch holes\*(R"
in the backing store.  If that is not possible then you can omit this
callback.
.PP
This function will not be called if \f(CW\*(C`.can_trim\*(C'\fR returned false.  The
parameter \f(CW\*(C`flags\*(C'\fR may include \f(CW\*(C`NBDKIT_FLAG_FUA\*(C'\fR on input based on
the result of \f(CW\*(C`.can_fua\*(C'\fR.
.PP
If there is an error, \f(CW\*(C`.trim\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an
error message, and \f(CW\*(C`nbdkit_set_error\*(C'\fR to record an appropriate error
(unless \f(CW\*(C`errno\*(C'\fR is sufficient), then return \f(CW\*(C`\-1\*(C'\fR.
.ie n .SS """.zero"""
.el .SS "\f(CW.zero\fP"
.IX Subsection ".zero"
.Vb 1
\& int zero (void *handle, uint32_t count, uint64_t offset, uint32_t flags);
.Ve
.PP
During the data serving phase, this callback is used to write \f(CW\*(C`count\*(C'\fR
bytes of zeroes at \f(CW\*(C`offset\*(C'\fR in the backing store.
.PP
This function will not be called if \f(CW\*(C`.can_zero\*(C'\fR returned false.  On
input, the parameter \f(CW\*(C`flags\*(C'\fR may include \f(CW\*(C`NBDKIT_FLAG_MAY_TRIM\*(C'\fR
unconditionally, \f(CW\*(C`NBDKIT_FLAG_FUA\*(C'\fR based on the result of
\&\f(CW\*(C`.can_fua\*(C'\fR, and \f(CW\*(C`NBDKIT_FLAG_FAST_ZERO\*(C'\fR based on the result of
\&\f(CW\*(C`.can_fast_zero\*(C'\fR.
.PP
If \f(CW\*(C`NBDKIT_FLAG_MAY_TRIM\*(C'\fR is requested, the operation can punch a
hole instead of writing actual zero bytes, but only if subsequent
reads from the hole read as zeroes.
.PP
If \f(CW\*(C`NBDKIT_FLAG_FAST_ZERO\*(C'\fR is requested, the plugin must decide up
front if the implementation is likely to be faster than a
corresponding \f(CW\*(C`.pwrite\*(C'\fR; if not, then it must immediately fail with
\&\f(CW\*(C`ENOTSUP\*(C'\fR or \f(CW\*(C`EOPNOTSUPP\*(C'\fR (whether by \f(CW\*(C`nbdkit_set_error\*(C'\fR or
\&\f(CW\*(C`errno\*(C'\fR) and preferably without modifying the exported image.  It is
acceptable to always fail a fast zero request (as a fast failure is
better than attempting the write only to find out after the fact that
it was not fast after all).  Note that on Linux, support for
\&\f(CW\*(C`ioctl(BLKZEROOUT)\*(C'\fR is insufficient for determining whether a zero
request to a block device will be fast (because the kernel will
perform a slow fallback when needed).
.PP
The callback must write the whole \f(CW\*(C`count\*(C'\fR bytes if it can.  The \s-1NBD\s0
protocol doesn't allow partial writes (instead, these would be
errors).  If the whole \f(CW\*(C`count\*(C'\fR bytes was written successfully, the
callback should return \f(CW0\fR to indicate there was \fIno\fR error.
.PP
If there is an error, \f(CW\*(C`.zero\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an
error message, and \f(CW\*(C`nbdkit_set_error\*(C'\fR to record an appropriate error
(unless \f(CW\*(C`errno\*(C'\fR is sufficient), then return \f(CW\*(C`\-1\*(C'\fR.
.PP
If this callback is omitted, or if it fails with \f(CW\*(C`ENOTSUP\*(C'\fR or
\&\f(CW\*(C`EOPNOTSUPP\*(C'\fR (whether by \f(CW\*(C`nbdkit_set_error\*(C'\fR or \f(CW\*(C`errno\*(C'\fR), then
\&\f(CW\*(C`.pwrite\*(C'\fR will be used as an automatic fallback except when the
client requested a fast zero.
.ie n .SS """.extents"""
.el .SS "\f(CW.extents\fP"
.IX Subsection ".extents"
.Vb 2
\& int extents (void *handle, uint32_t count, uint64_t offset,
\&              uint32_t flags, struct nbdkit_extents *extents);
.Ve
.PP
During the data serving phase, this callback is used to detect
allocated, sparse and zeroed regions of the disk.
.PP
This function will not be called if \f(CW\*(C`.can_extents\*(C'\fR returned false.
nbdkit's default behaviour in this case is to treat the whole virtual
disk as if it was allocated.  Also, this function will not be called
by a client that does not request structured replies (the \fI\-\-no\-sr\fR
option of nbdkit can be used to test behavior when \f(CW\*(C`.extents\*(C'\fR is
unavailable to the client).
.PP
The callback should detect and return the list of extents overlapping
the range \f(CW\*(C`[offset...offset+count\-1]\*(C'\fR.  The \f(CW\*(C`extents\*(C'\fR parameter
points to an opaque object which the callback should fill in by
calling \f(CW\*(C`nbdkit_add_extent\*(C'\fR.  See \*(L"Extents list\*(R" below.
.PP
If there is an error, \f(CW\*(C`.extents\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an
error message, and \f(CW\*(C`nbdkit_set_error\*(C'\fR to record an appropriate error
(unless \f(CW\*(C`errno\*(C'\fR is sufficient), then return \f(CW\*(C`\-1\*(C'\fR.
.PP
\fIExtents list\fR
.IX Subsection "Extents list"
.PP
The plugin \f(CW\*(C`extents\*(C'\fR callback is passed an opaque pointer \f(CW\*(C`struct
nbdkit_extents *extents\*(C'\fR.  This structure represents a list of
filesystem extents
describing which areas of the disk are allocated, which are sparse
(“holes”), and, if supported, which are zeroes.
.PP
The \f(CW\*(C`extents\*(C'\fR callback should scan the disk starting at \f(CW\*(C`offset\*(C'\fR and
call \f(CW\*(C`nbdkit_add_extent\*(C'\fR for each extent found.
.PP
Extents overlapping the range \f(CW\*(C`[offset...offset+count\-1]\*(C'\fR should be
returned if possible.  However nbdkit ignores extents < offset so
the plugin may, if it is easier to implement, return all extent
information for the whole disk.  The plugin may return extents beyond
the end of the range.  It may also return extent information for less
than the whole range, but it must return at least one extent
overlapping \f(CW\*(C`offset\*(C'\fR.
.PP
The extents \fBmust\fR be added in ascending order, and \fBmust\fR be
contiguous.
.PP
The \f(CW\*(C`flags\*(C'\fR parameter of the \f(CW\*(C`.extents\*(C'\fR callback may contain the
flag \f(CW\*(C`NBDKIT_FLAG_REQ_ONE\*(C'\fR.  This means that the client is only
requesting information about the extent overlapping \f(CW\*(C`offset\*(C'\fR.  The
plugin may ignore this flag, or as an optimization it may return just
a single extent for \f(CW\*(C`offset\*(C'\fR.
.PP
.Vb 2
\& int nbdkit_add_extent (struct nbdkit_extents *extents,
\&                        uint64_t offset, uint64_t length, uint32_t type);
.Ve
.PP
Add an extent covering \f(CW\*(C`[offset...offset+length\-1]\*(C'\fR of one of
the following four types:
.ie n .IP """type = 0""" 4
.el .IP "\f(CWtype = 0\fR" 4
.IX Item "type = 0"
A normal, allocated data extent.
.ie n .IP """type = NBDKIT_EXTENT_HOLE|NBDKIT_EXTENT_ZERO""" 4
.el .IP "\f(CWtype = NBDKIT_EXTENT_HOLE|NBDKIT_EXTENT_ZERO\fR" 4
.IX Item "type = NBDKIT_EXTENT_HOLE|NBDKIT_EXTENT_ZERO"
An unallocated extent, a.k.a. a “hole”, which reads back as zeroes.
This is the normal type of hole applicable to most disks.
.ie n .IP """type = NBDKIT_EXTENT_ZERO""" 4
.el .IP "\f(CWtype = NBDKIT_EXTENT_ZERO\fR" 4
.IX Item "type = NBDKIT_EXTENT_ZERO"
An allocated extent which is known to contain only zeroes.
.ie n .IP """type = NBDKIT_EXTENT_HOLE""" 4
.el .IP "\f(CWtype = NBDKIT_EXTENT_HOLE\fR" 4
.IX Item "type = NBDKIT_EXTENT_HOLE"
An unallocated extent (hole) which does not read back as zeroes.  Note
this should only be used in specialized circumstances such as when
writing a plugin for (or to emulate) certain \s-1SCSI\s0 drives which do not
guarantee that trimmed blocks read back as zeroes.
.PP
\&\f(CW\*(C`nbdkit_add_extent\*(C'\fR returns \f(CW0\fR on success or \f(CW\*(C`\-1\*(C'\fR on failure.  On
failure \f(CW\*(C`nbdkit_error\*(C'\fR and/or \f(CW\*(C`nbdkit_set_error\*(C'\fR has already been
called.  \f(CW\*(C`errno\*(C'\fR will be set to a suitable value.
.ie n .SS """.cache"""
.el .SS "\f(CW.cache\fP"
.IX Subsection ".cache"
.Vb 1
\& int cache (void *handle, uint32_t count, uint64_t offset, uint32_t flags);
.Ve
.PP
During the data serving phase, this callback is used to give the
plugin a hint that the client intends to make further accesses to the
given region of the export.  The nature of caching is not specified
further by the \s-1NBD\s0 specification (for example, a server may place
limits on how much may be cached at once, and there is no way to
control if writes to a cached area have write-through or write-back
semantics).  In fact, the cache command can always fail and still be
compliant, and success might not guarantee a performance gain.  If
this callback is omitted, then the results of \f(CW\*(C`.can_cache\*(C'\fR determine
whether nbdkit will reject cache requests, treat them as instant
success, or emulate caching by calling \f(CW\*(C`.pread\*(C'\fR over the same region
and ignoring the results.
.PP
This function will not be called if \f(CW\*(C`.can_cache\*(C'\fR did not return
\&\f(CW\*(C`NBDKIT_CACHE_NATIVE\*(C'\fR.  The parameter \f(CW\*(C`flags\*(C'\fR exists in case of
future \s-1NBD\s0 protocol extensions; at this time, it will be 0 on input. A
plugin must fail this function if \f(CW\*(C`flags\*(C'\fR includes an unrecognized
flag, as that may indicate a requirement that the plugin comply must
with a specific caching semantic.
.PP
If there is an error, \f(CW\*(C`.cache\*(C'\fR should call \f(CW\*(C`nbdkit_error\*(C'\fR with an
error message, and \f(CW\*(C`nbdkit_set_error\*(C'\fR to record an appropriate error
(unless \f(CW\*(C`errno\*(C'\fR is sufficient), then return \f(CW\*(C`\-1\*(C'\fR.
.ie n .SS """.errno_is_preserved"""
.el .SS "\f(CW.errno_is_preserved\fP"
.IX Subsection ".errno_is_preserved"
This field defaults to 0; if non-zero, nbdkit can reliably use the
value of \f(CW\*(C`errno\*(C'\fR when a callback reports failure, rather than the
plugin having to call \f(CW\*(C`nbdkit_set_error\*(C'\fR.
.SH "SHUTDOWN"
.IX Header "SHUTDOWN"
When nbdkit receives certain signals it will shut down (see
\&\*(L"\s-1SIGNALS\*(R"\s0 in \fInbdkit\fR\|(1)).  The server will wait for any currently running
plugin callbacks to finish and also call the \f(CW\*(C`.unload\*(C'\fR callback
before unloading the plugin.
.PP
Note that it's not guaranteed this can always happen (eg. the server
might be killed by \f(CW\*(C`SIGKILL\*(C'\fR or segfault).
.SS "Requesting asynchronous shutdown"
.IX Subsection "Requesting asynchronous shutdown"
Plugins and filters can call \fIexit\fR\|(3) in the configuration phase
(before and including \f(CW\*(C`.get_ready\*(C'\fR, but not in connected callbacks).
.PP
Once nbdkit has started serving connections, plugins and filters
should not call \fIexit\fR\|(3).  However they may instruct nbdkit to shut
down by calling \f(CW\*(C`nbdkit_shutdown\*(C'\fR:
.PP
.Vb 1
\& void nbdkit_shutdown (void);
.Ve
.PP
This function requests an asynchronous shutdown and returns (\fInote\fR
that it does \fInot\fR exit the process immediately).  It ensures that
the plugin and all filters are unloaded cleanly which may take some
time.  Further callbacks from nbdkit into the plugin or filter may
occur after you have called this.
.SH "PARSING COMMAND LINE PARAMETERS"
.IX Header "PARSING COMMAND LINE PARAMETERS"
.SS "Parsing numbers"
.IX Subsection "Parsing numbers"
There are several functions for parsing numbers.  These all deal
correctly with overflow, out of range and parse errors, and you should
use them instead of unsafe functions like \fIsscanf\fR\|(3), \fIatoi\fR\|(3) and
similar.
.PP
.Vb 10
\& int nbdkit_parse_int (const char *what, const char *str, int *r);
\& int nbdkit_parse_unsigned (const char *what,
\&                            const char *str, unsigned *r);
\& int nbdkit_parse_int8_t (const char *what,
\&                          const char *str, int8_t *r);
\& int nbdkit_parse_uint8_t (const char *what,
\&                           const char *str, uint8_t *r);
\& int nbdkit_parse_int16_t (const char *what,
\&                           const char *str, int16_t *r);
\& int nbdkit_parse_uint16_t (const char *what,
\&                            const char *str, uint16_t *r);
\& int nbdkit_parse_int32_t (const char *what,
\&                           const char *str, int32_t *r);
\& int nbdkit_parse_uint32_t (const char *what,
\&                            const char *str, uint32_t *r);
\& int nbdkit_parse_int64_t (const char *what,
\&                           const char *str, int64_t *r);
\& int nbdkit_parse_uint64_t (const char *what,
\&                            const char *str, uint64_t *r);
.Ve
.PP
Parse string \f(CW\*(C`str\*(C'\fR into an integer of various types.  These functions
parse a decimal, hexadecimal (\f(CW"0x..."\fR) or octal (\f(CW"0..."\fR) number.
.PP
On success the functions return \f(CW0\fR and set \f(CW*r\fR to the parsed value
(unless \f(CW\*(C`*r == NULL\*(C'\fR in which case the result is discarded).  On
error, \f(CW\*(C`nbdkit_error\*(C'\fR is called and the functions return \f(CW\*(C`\-1\*(C'\fR.  On
error \f(CW*r\fR is always unchanged.
.PP
The \f(CW\*(C`what\*(C'\fR parameter is printed in error messages to provide context.
It should usually be a short descriptive string of what you are trying
to parse, eg:
.PP
.Vb 2
\& if (nbdkit_parse_int ("random seed", argv[1], &seed) == \-1)
\&   return \-1;
.Ve
.PP
might print an error:
.PP
.Vb 1
\& random seed: could not parse number: "lalala"
.Ve
.SS "Parsing sizes"
.IX Subsection "Parsing sizes"
Use the \f(CW\*(C`nbdkit_parse_size\*(C'\fR utility function to parse human-readable
size strings such as \*(L"100M\*(R" into the size in bytes.
.PP
.Vb 1
\& int64_t nbdkit_parse_size (const char *str);
.Ve
.PP
\&\f(CW\*(C`str\*(C'\fR can be a string in a number of common formats.  The function
returns the size in bytes.  If there was an error, it returns \f(CW\*(C`\-1\*(C'\fR.
.SS "Parsing booleans"
.IX Subsection "Parsing booleans"
Use the \f(CW\*(C`nbdkit_parse_bool\*(C'\fR utility function to parse human-readable
strings such as \*(L"on\*(R" into a boolean value.
.PP
.Vb 1
\& int nbdkit_parse_bool (const char *str);
.Ve
.PP
\&\f(CW\*(C`str\*(C'\fR can be a string containing a case-insensitive form of various
common toggle values.  The function returns 0 or 1 if the parse was
successful.  If there was an error, it returns \f(CW\*(C`\-1\*(C'\fR.
.SS "Reading passwords"
.IX Subsection "Reading passwords"
The \f(CW\*(C`nbdkit_read_password\*(C'\fR utility function can be used to read
passwords from config parameters:
.PP
.Vb 1
\& int nbdkit_read_password (const char *value, char **password);
.Ve
.PP
For example:
.PP
.Vb 1
\& char *password = NULL;
\& 
\& static int
\& myplugin_config (const char *key, const char *value)
\& {
\&   ..
\&   if (strcmp (key, "password") == 0) {
\&     free (password);
\&     if (nbdkit_read_password (value, &password) == \-1)
\&       return \-1;
\&   }
\&   ..
\& }
.Ve
.PP
The \f(CW\*(C`password\*(C'\fR result string is allocated by malloc, and so you may
need to free it.
.PP
This function recognizes several password formats.  A password may be
used directly on the command line, eg:
.PP
.Vb 1
\& nbdkit myplugin password=mostsecret
.Ve
.PP
But more securely this function can also read a password
interactively:
.PP
.Vb 1
\& nbdkit myplugin password=\-
.Ve
.PP
or from a file:
.PP
.Vb 1
\& nbdkit myplugin password=+/tmp/secret
.Ve
.PP
or from a file descriptor inherited by nbdkit:
.PP
.Vb 1
\& nbdkit myplugin password=\-99
.Ve
.PP
\fINotes on reading passwords\fR
.IX Subsection "Notes on reading passwords"
.PP
If the password begins with a \f(CW\*(C`\-\*(C'\fR or \f(CW\*(C`+\*(C'\fR character then it must be
passed in a file.
.PP
\&\f(CW\*(C`password=\-\*(C'\fR can only be used when stdin is a terminal.
.PP
\&\f(CW\*(C`password=\-FD\*(C'\fR cannot be used with stdin, stdout or stderr
(ie. \f(CW\*(C`\-0\*(C'\fR, \f(CW\*(C`\-1\*(C'\fR or \f(CW\*(C`\-2\*(C'\fR).  The reason is that after reading the
password the file descriptor is closed, which causes bad stuff to
happen.
.SS "Safely interacting with stdin and stdout"
.IX Subsection "Safely interacting with stdin and stdout"
.Vb 1
\& int nbdkit_stdio_safe (void);
.Ve
.PP
The \f(CW\*(C`nbdkit_stdio_safe\*(C'\fR utility function returns \f(CW1\fR if it is safe
to interact with stdin and stdout during the configuration phase, and
\&\f(CW0\fR otherwise.  This is because when the nbdkit \fI\-s\fR option is used
the plugin must not directly interact with stdin, because that would
interfere with the client.
.PP
The result of this function only matters in callbacks up to
\&\f(CW\*(C`.config_complete\*(C'\fR.  Once nbdkit reaches \f(CW\*(C`.get_ready\*(C'\fR, the plugin
should assume that nbdkit may have closed the original stdin and
stdout in order to become a daemon.
.PP
\&\fInbdkit\-sh\-plugin\fR\|(3) uses this function to determine whether it is
safe to support \f(CW\*(C`script=\-\*(C'\fR to read a script from stdin.  Also
constructs like \f(CW\*(C`password=\-\*(C'\fR (see \*(L"Reading passwords\*(R" above) are
disabled when reading from stdio is not safe.
.SH "FILENAMES AND PATHS"
.IX Header "FILENAMES AND PATHS"
The server usually (not always) changes directory to \f(CW\*(C`/\*(C'\fR before it
starts serving connections.  This means that any relative paths passed
during configuration will not work when the server is running
(example: \f(CW\*(C`nbdkit plugin.so disk.img\*(C'\fR).
.PP
To avoid problems, prepend relative paths with the current directory
before storing them in the handle.  Or open files and store the file
descriptor.
.ie n .SS """nbdkit_absolute_path"""
.el .SS "\f(CWnbdkit_absolute_path\fP"
.IX Subsection "nbdkit_absolute_path"
.Vb 1
\& char *nbdkit_absolute_path (const char *filename);
.Ve
.PP
The utility function \f(CW\*(C`nbdkit_absolute_path\*(C'\fR converts any path to an
absolute path: if it is relative, then all this function does is
prepend the current working directory to the path, with no extra
checks.
.PP
Note that this function works \fIonly\fR when used in the \f(CW\*(C`.config\*(C'\fR,
\&\f(CW\*(C`.config_complete\*(C'\fR and \f(CW\*(C`.get_ready\*(C'\fR callbacks.
.PP
If conversion was not possible, this calls \f(CW\*(C`nbdkit_error\*(C'\fR and returns
\&\f(CW\*(C`NULL\*(C'\fR.  Note that this function does not check that the file exists.
.PP
The returned string must be freed by the caller.
.ie n .SS """nbdkit_realpath"""
.el .SS "\f(CWnbdkit_realpath\fP"
.IX Subsection "nbdkit_realpath"
.Vb 1
\& char *nbdkit_realpath (const char *filename);
.Ve
.PP
The utility function \f(CW\*(C`nbdkit_realpath\*(C'\fR converts any path to an
absolute path, resolving symlinks.  Under the hood it uses the
\&\f(CW\*(C`realpath\*(C'\fR function, and thus it fails if the path does not exist,
or it is not possible to access to any of the components of the path.
.PP
Note that this function works \fIonly\fR when used in the \f(CW\*(C`.config\*(C'\fR,
\&\f(CW\*(C`.config_complete\*(C'\fR and \f(CW\*(C`.get_ready\*(C'\fR callbacks.
.PP
If the path resolution was not possible, this calls \f(CW\*(C`nbdkit_error\*(C'\fR
and returns \f(CW\*(C`NULL\*(C'\fR.
.PP
The returned string must be freed by the caller.
.SS "umask"
.IX Subsection "umask"
All plugins will see a \fIumask\fR\|(2) of \f(CW0022\fR.
.SH "SLEEPING"
.IX Header "SLEEPING"
A plugin that needs to sleep may call \fIsleep\fR\|(2), \fInanosleep\fR\|(2) and
similar.  However that can cause nbdkit to delay excessively when
shutting down (since it must wait for any plugin or filter which is
sleeping).  To avoid this there is a special wrapper around nanosleep
which plugins and filters should use instead.
.ie n .SS """nbdkit_nanosleep"""
.el .SS "\f(CWnbdkit_nanosleep\fP"
.IX Subsection "nbdkit_nanosleep"
.Vb 1
\& int nbdkit_nanosleep (unsigned sec, unsigned nsec);
.Ve
.PP
The utility function \f(CW\*(C`nbdkit_nanosleep\*(C'\fR suspends the current thread,
and returns 0 if it slept at least as many seconds and nanoseconds as
requested, or \-1 after calling \f(CW\*(C`nbdkit_error\*(C'\fR if there is no point in
continuing the current command.  Attempts to sleep more than
\&\f(CW\*(C`INT_MAX\*(C'\fR seconds are treated as an error.
.SH "EXPORT NAME"
.IX Header "EXPORT NAME"
If the client negotiated an \s-1NBD\s0 export name with nbdkit then plugins
may read this from any connected callbacks.  Nbdkit's normal behaviour
is to accept any export name passed by the client, log it in debug
output, but otherwise ignore it.  By using \f(CW\*(C`nbdkit_export_name\*(C'\fR
plugins may choose to filter by export name or serve different
content.
.ie n .SS """nbdkit_export_name"""
.el .SS "\f(CWnbdkit_export_name\fP"
.IX Subsection "nbdkit_export_name"
.Vb 1
\& const char *nbdkit_export_name (void);
.Ve
.PP
Return the optional \s-1NBD\s0 export name if one was negotiated with the
current client (this uses thread-local magic so no parameter is
required).  The returned string is only valid while the client is
connected, so if you need to store it in the plugin you must copy it.
.PP
The export name is a free-form text string, it is not necessarily a
path or filename and it does not need to begin with a \f(CW\*(Aq/\*(Aq\fR
character.  The \s-1NBD\s0 protocol describes the empty string (\f(CW""\fR) as a
representing a \*(L"default export\*(R" or to be used in cases where the
export name does not make sense.  \fBThe export name is untrusted
client data, be cautious when parsing it.\fR
.PP
On error, \f(CW\*(C`nbdkit_error\*(C'\fR is called and the call returns \f(CW\*(C`NULL\*(C'\fR.
.SH "PEER NAME"
.IX Header "PEER NAME"
It is possible to get the address of the client when you are running
in any connected callback.
.ie n .SS """nbdkit_peer_name"""
.el .SS "\f(CWnbdkit_peer_name\fP"
.IX Subsection "nbdkit_peer_name"
.Vb 1
\& int nbdkit_peer_name (struct sockaddr *addr, socklen_t *addrlen);
.Ve
.PP
Return the peer (client) address, if available.  The \f(CW\*(C`addr\*(C'\fR and
\&\f(CW\*(C`addrlen\*(C'\fR parameters behave like \fIgetpeername\fR\|(2).  In particular
you must initialize \f(CW\*(C`addrlen\*(C'\fR with the size of the buffer pointed to
by \f(CW\*(C`addr\*(C'\fR, and if \f(CW\*(C`addr\*(C'\fR is not large enough then the address will
be truncated.
.PP
In some cases this is not available or the address returned will be
meaningless (eg. if there is a proxy between the client and nbdkit).
This call uses thread-local magic so no parameter is required to
specify the current connection.
.PP
On success this returns \f(CW0\fR.  On error, \f(CW\*(C`nbdkit_error\*(C'\fR is called and
this call returns \f(CW\*(C`\-1\*(C'\fR.
.SH "DEBUGGING"
.IX Header "DEBUGGING"
Run the server with \fI\-f\fR and \fI\-v\fR options so it doesn't fork and you
can see debugging information:
.PP
.Vb 1
\& nbdkit \-fv ./myplugin.so [key=value [key=value [...]]]
.Ve
.PP
To print debugging information from within the plugin, call
\&\f(CW\*(C`nbdkit_debug\*(C'\fR, which has the following prototype and works like
\&\fIprintf\fR\|(3):
.PP
.Vb 2
\& void nbdkit_debug (const char *fs, ...);
\& void nbdkit_vdebug (const char *fs, va_list args);
.Ve
.PP
For convenience, \f(CW\*(C`nbdkit_debug\*(C'\fR preserves the value of \f(CW\*(C`errno\*(C'\fR, and
also supports the glibc extension of a single \f(CW%m\fR in a format string
expanding to \f(CW\*(C`strerror(errno)\*(C'\fR, even on platforms that don't support
that natively. Note that \f(CW\*(C`nbdkit_debug\*(C'\fR only prints things when the
server is in verbose mode (\fI\-v\fR option).
.SS "Debug Flags"
.IX Subsection "Debug Flags"
The \fI\-v\fR option switches general debugging on or off, and this
debugging should be used for messages which are useful for all users
of your plugin.
.PP
In cases where you want to enable specific extra debugging to track
down bugs in plugins or filters — mainly for use by the plugin/filter
developers themselves — you can define Debug Flags.  These are global
ints called \f(CW\*(C`myplugin_debug_*\*(C'\fR:
.PP
.Vb 6
\& int myplugin_debug_foo;
\& int myplugin_debug_bar;
\& ...
\& if (myplugin_debug_foo) {
\&   nbdkit_debug ("lots of extra debugging about foo: ...");
\& }
.Ve
.PP
Debug Flags can be controlled on the command line using the \fI\-D\fR (or
\&\fI\-\-debug\fR) option:
.PP
.Vb 1
\& nbdkit \-f \-v \-D myplugin.foo=1 \-D myplugin.bar=2 myplugin [...]
.Ve
.PP
Note \f(CW\*(C`myplugin\*(C'\fR is the name passed to \f(CW\*(C`.name\*(C'\fR in the \f(CW\*(C`struct
nbdkit_plugin\*(C'\fR.
.PP
You should only use this feature for debug settings.  For general
settings use ordinary plugin parameters.  Debug Flags can only be C
ints.  They are not supported by non-C language plugins.
.PP
For convenience \f(CW\*(Aq.\*(Aq\fR characters are replaced with \f(CW\*(Aq_\*(Aq\fR characters
in the variable name, so both of these parameters:
.PP
.Vb 2
\& \-D myplugin.foo_bar=1
\& \-D myplugin.foo.bar=1
.Ve
.PP
correspond to the plugin variable \f(CW\*(C`myplugin_debug_foo_bar\*(C'\fR.
.SH "COMPILING THE PLUGIN"
.IX Header "COMPILING THE PLUGIN"
Plugins should be compiled as shared libraries.  There are various
ways to achieve this, but most Linux compilers support a \fI\-shared\fR
option to create the shared library directly, for example:
.PP
.Vb 1
\& gcc \-fPIC \-shared myplugin.c \-o myplugin.so
.Ve
.PP
Note that the shared library will have undefined symbols for functions
that you call like \f(CW\*(C`nbdkit_parse_int\*(C'\fR or \f(CW\*(C`nbdkit_error\*(C'\fR.  These will
be resolved by the server binary when nbdkit dlopens the plugin.
.SS "\s-1PKG\-CONFIG/PKGCONF\s0"
.IX Subsection "PKG-CONFIG/PKGCONF"
nbdkit provides a pkg\-config/pkgconf file called \f(CW\*(C`nbdkit.pc\*(C'\fR which
should be installed on the correct path when the nbdkit plugin
development environment is installed.  You can use this in autoconf
\&\fIconfigure.ac\fR scripts to test for the development environment:
.PP
.Vb 1
\& PKG_CHECK_MODULES([NBDKIT], [nbdkit >= 1.2.3])
.Ve
.PP
The above will fail unless nbdkit ≥ 1.2.3 and the header file is
installed, and will set \f(CW\*(C`NBDKIT_CFLAGS\*(C'\fR and \f(CW\*(C`NBDKIT_LIBS\*(C'\fR
appropriately for compiling plugins.
.PP
You can also run pkg\-config/pkgconf directly, for example:
.PP
.Vb 4
\& if ! pkg\-config nbdkit \-\-exists; then
\&   echo "you must install the nbdkit plugin development environment"
\&   exit 1
\& fi
.Ve
.PP
You can also substitute the plugindir variable by doing:
.PP
.Vb 1
\& PKG_CHECK_VAR([NBDKIT_PLUGINDIR], [nbdkit], [plugindir])
.Ve
.PP
which defines \f(CW\*(C`$(NBDKIT_PLUGINDIR)\*(C'\fR in automake-generated Makefiles.
.PP
If nbdkit development headers are installed in a non-standard location
then you may need to compile plugins using:
.PP
.Vb 2
\& gcc \-fPIC \-shared myplugin.c \-o myplugin.so \e
\&   \`pkg\-config nbdkit \-\-cflags \-\-libs\`
.Ve
.SH "INSTALLING THE PLUGIN"
.IX Header "INSTALLING THE PLUGIN"
The plugin is a \f(CW\*(C`*.so\*(C'\fR file and possibly a manual page.  You can of
course install the plugin \f(CW\*(C`*.so\*(C'\fR file wherever you want, and users
will be able to use it by running:
.PP
.Vb 1
\& nbdkit /path/to/plugin.so [args]
.Ve
.PP
However \fBif\fR the shared library has a name of the form
\&\f(CW\*(C`nbdkit\-\f(CIname\f(CW\-plugin.so\*(C'\fR \fBand if\fR the library is installed in the
\&\f(CW$plugindir\fR directory, then users can be run it by only typing:
.PP
.Vb 1
\& nbdkit name [args]
.Ve
.PP
The location of the \f(CW$plugindir\fR directory is set when nbdkit is
compiled and can be found by doing:
.PP
.Vb 1
\& nbdkit \-\-dump\-config
.Ve
.PP
If using the pkg\-config/pkgconf system then you can also find the
plugin directory at compile time by doing:
.PP
.Vb 1
\& pkg\-config nbdkit \-\-variable=plugindir
.Ve
.SH "WRITING PLUGINS IN OTHER PROGRAMMING LANGUAGES"
.IX Header "WRITING PLUGINS IN OTHER PROGRAMMING LANGUAGES"
You can also write nbdkit plugins in Go, Lua, OCaml, Perl, Python,
Ruby, Rust, shell script or Tcl.  Other programming languages may be
offered in future.
.PP
For more information see:
\&\fInbdkit\-cc\-plugin\fR\|(3),
\&\fInbdkit\-golang\-plugin\fR\|(3),
\&\fInbdkit\-lua\-plugin\fR\|(3),
\&\fInbdkit\-ocaml\-plugin\fR\|(3),
\&\fInbdkit\-perl\-plugin\fR\|(3),
\&\fInbdkit\-python\-plugin\fR\|(3),
\&\fInbdkit\-ruby\-plugin\fR\|(3),
\&\fInbdkit\-rust\-plugin\fR\|(3),
\&\fInbdkit\-sh\-plugin\fR\|(3),
\&\fInbdkit\-tcl\-plugin\fR\|(3)
\&.
.PP
Plugins written in scripting languages may also be installed in
\&\f(CW$plugindir\fR.  These must be called \f(CW\*(C`nbdkit\-\f(CIname\f(CW\-plugin\*(C'\fR without
any extension.  They must be executable, and they must use the shebang
header (see \*(L"Shebang scripts\*(R" in \fInbdkit\fR\|(1)).  For example a plugin
written in Perl called \f(CW\*(C`foo.pl\*(C'\fR might be installed like this:
.PP
.Vb 2
\& $ head \-1 foo.pl
\& #!/usr/sbin/nbdkit perl
\&
\& $ sudo install \-m 0755 foo.pl $plugindir/nbdkit\-foo\-plugin
.Ve
.PP
and then users will be able to run it like this:
.PP
.Vb 1
\& $ nbdkit foo [args ...]
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fInbdkit\fR\|(1),
\&\fInbdkit\-nozero\-filter\fR\|(3),
\&\fInbdkit\-filter\fR\|(3).
.PP
Standard plugins provided by nbdkit:
.PP
\&\fInbdkit\-curl\-plugin\fR\|(1),
\&\fInbdkit\-data\-plugin\fR\|(1),
\&\fInbdkit\-eval\-plugin\fR\|(1),
\&\fInbdkit\-example1\-plugin\fR\|(1),
\&\fInbdkit\-example2\-plugin\fR\|(1),
\&\fInbdkit\-example3\-plugin\fR\|(1),
\&\fInbdkit\-example4\-plugin\fR\|(1),
\&\fInbdkit\-ext2\-plugin\fR\|(1),
\&\fInbdkit\-file\-plugin\fR\|(1),
\&\fInbdkit\-floppy\-plugin\fR\|(1),
\&\fInbdkit\-full\-plugin\fR\|(1),
\&\fInbdkit\-guestfs\-plugin\fR\|(1),
\&\fInbdkit\-gzip\-plugin\fR\|(1),
\&\fInbdkit\-info\-plugin\fR\|(1),
\&\fInbdkit\-iso\-plugin\fR\|(1),
\&\fInbdkit\-libvirt\-plugin\fR\|(1),
\&\fInbdkit\-linuxdisk\-plugin\fR\|(1),
\&\fInbdkit\-memory\-plugin\fR\|(1),
\&\fInbdkit\-nbd\-plugin\fR\|(1),
\&\fInbdkit\-null\-plugin\fR\|(1),
\&\fInbdkit\-partitioning\-plugin\fR\|(1),
\&\fInbdkit\-pattern\-plugin\fR\|(1),
\&\fInbdkit\-random\-plugin\fR\|(1),
\&\fInbdkit\-split\-plugin\fR\|(1),
\&\fInbdkit\-ssh\-plugin\fR\|(1),
\&\fInbdkit\-streaming\-plugin\fR\|(1),
\&\fInbdkit\-tar\-plugin\fR\|(1),
\&\fInbdkit\-tmpdisk\-plugin\fR\|(1),
\&\fInbdkit\-vddk\-plugin\fR\|(1),
\&\fInbdkit\-zero\-plugin\fR\|(1)
;
\&\fInbdkit\-cc\-plugin\fR\|(3),
\&\fInbdkit\-golang\-plugin\fR\|(3),
\&\fInbdkit\-lua\-plugin\fR\|(3),
\&\fInbdkit\-ocaml\-plugin\fR\|(3),
\&\fInbdkit\-perl\-plugin\fR\|(3),
\&\fInbdkit\-python\-plugin\fR\|(3),
\&\fInbdkit\-ruby\-plugin\fR\|(3),
\&\fInbdkit\-rust\-plugin\fR\|(3),
\&\fInbdkit\-sh\-plugin\fR\|(3),
\&\fInbdkit\-tcl\-plugin\fR\|(3)
\&.
.SH "AUTHORS"
.IX Header "AUTHORS"
Eric Blake
.PP
Richard W.M. Jones
.PP
Pino Toscano
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2013\-2020 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:
.IP "\(bu" 4
Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
.IP "\(bu" 4
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
.IP "\(bu" 4
Neither the name of Red Hat nor the names of its contributors may be
used to endorse or promote products derived from this software without
specific prior written permission.
.PP
\&\s-1THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS\s0 ''\s-1AS IS\s0'' \s-1AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\s0 (\s-1INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES\s0; \s-1LOSS OF
USE, DATA, OR PROFITS\s0; \s-1OR BUSINESS INTERRUPTION\s0) \s-1HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT\s0 (\s-1INCLUDING NEGLIGENCE OR OTHERWISE\s0) \s-1ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.\s0
