.\" Automatically generated by Podwrapper::Man 1.21.8 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "nbdkit-sh-plugin 3"
.TH nbdkit-sh-plugin 3 "2020-06-10" "nbdkit-1.21.8" "NBDKIT"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
nbdkit\-sh\-plugin \- nbdkit shell, script or executable plugin
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& nbdkit sh /path/to/script [arguments...]
\&
\& nbdkit sh \- <<\*(AqEOF\*(Aq
\& ... shell script ...
\& EOF
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`nbdkit\-sh\-plugin\*(C'\fR allows you to write plugins for \fInbdkit\fR\|(1) using
arbitrary scripting languages, including shells like \fIbash\fR\|(1),
\&\fIdash\fR\|(1), \fIcsh\fR\|(1), \fIzsh\fR\|(1) etc., other scripting environments,
or any executable.
.PP
Note if you want to use an established scripting language like Perl or
Python, then nbdkit has specific plugins to handle those languages and
those will be more efficient (see \fInbdkit\fR\|(1) for a complete list).
.PP
To use shell script fragments from the nbdkit command line (rather
than a separate script) see \fInbdkit\-eval\-plugin\fR\|(1).
.SS "If you have been given an nbdkit sh plugin"
.IX Subsection "If you have been given an nbdkit sh plugin"
Assuming you have a shell script which is an nbdkit plugin, you run it
like this:
.PP
.Vb 1
\& nbdkit sh /path/to/script
.Ve
.PP
You may have to add further \f(CW\*(C`key=value\*(C'\fR arguments to the command
line.  The script must be executable (\f(CW\*(C`chmod +x\*(C'\fR).
.SS "Inline shell scripts"
.IX Subsection "Inline shell scripts"
It is also possible to write a shell script plugin \*(L"inline\*(R" using \f(CW\*(C`\-\*(C'\fR
as the name of the script, like this:
.PP
.Vb 7
\& nbdkit sh \- <<\*(AqEOF\*(Aq
\&   case "$1" in
\&     get_size) echo 1M ;;
\&     pread) dd if=/dev/zero count=$3 iflag=count_bytes ;;
\&     *) exit 2 ;;
\&   esac
\& EOF
.Ve
.PP
By default the inline script runs under \fI/bin/sh\fR.  You can add a
shebang (\f(CW\*(C`#!\*(C'\fR) to use other scripting languages.  Of course, reading
an inline script from stdin is incompatible with the \f(CW\*(C`\-s\*(C'\fR
(\f(CW\*(C`\-\-single\*(C'\fR) mode of nbdkit that connects a client on stdin.
.SH "WRITING AN NBDKIT SH PLUGIN"
.IX Header "WRITING AN NBDKIT SH PLUGIN"
For an example plugin written in Bash, see:
https://github.com/libguestfs/nbdkit/blob/master/plugins/sh/example.sh
.PP
Broadly speaking, nbdkit shell plugins work like C ones, so you should
read \fInbdkit\-plugin\fR\|(3) first.
.SS "Programming model"
.IX Subsection "Programming model"
This plugin has a simple programming model: For every plugin method
that needs to be called, the external script is invoked with
parameters describing the method and its arguments.  The first
parameter is always the method name.  For example:
.PP
.Vb 5
\& /path/to/script config file disk.img
\&                   │      │   │
\&                   │      │   └─ value ($3)
\&                   │      └── key ($2)
\&               method ($1)
\&
\& /path/to/script pread <handle> <count> <offset>
\&                   │       │       │       │
\&                   │       │       │       └─ offset in bytes ($4)
\&                   │       │       └── request size in bytes ($3)
\&               method ($1) └── handle ($2) ─ see "Handles" below
.Ve
.PP
Scripts should ignore extra parameters that they don't understand
since we may add new parameters in future.
.SS "Exit codes"
.IX Subsection "Exit codes"
The script should exit with specific exit codes:
.IP "0" 4
The method was executed successfully.
.IP "1 and 8\-127" 4
.IX Item "1 and 8-127"
There was an error.  The script may print on stderr an errno name,
optionally followed by whitespace and a message, for example:
.Sp
.Vb 2
\& echo \*(AqENOSPC Out of space\*(Aq >&2
\& exit 1
.Ve
.Sp
or if you don't need the log message:
.Sp
.Vb 2
\& echo ENOSPC >&2
\& exit 1
.Ve
.Sp
If the script doesn't print anything or the output cannot be parsed
then nbdkit assumes error \f(CW\*(C`EIO\*(C'\fR.  Note that output to stderr is
ignored if the command succeeds, so it is acceptable to output a
potential error message prefix prior to attempting a command which
will add further details if a failure occurs.
.IP "2" 4
.IX Item "2"
The requested method is not supported by the script.
.IP "3" 4
.IX Item "3"
For methods which return booleans, this code indicates false.
.IP "4, 5, 6, 7" 4
.IX Item "4, 5, 6, 7"
These exit codes are reserved for future use.
.SS "Temporary directory"
.IX Subsection "Temporary directory"
A fresh script is invoked for each method call (ie. scripts are
stateless), so if the script needs to store state it has to store it
somewhere in the filesystem in a format and location which is left up
to the author of the script.
.PP
However nbdkit helps by creating a randomly named, empty directory for
the script.  This directory persists for the lifetime of nbdkit and is
deleted when nbdkit exits.  The name of the directory is passed to
each script invocation in the \f(CW$tmpdir\fR environment variable.
.SS "Handles"
.IX Subsection "Handles"
Handles are arbitrary strings, but it is best to limit them to short
alphanumeric strings.
.PP
\fIPer-connection state\fR
.IX Subsection "Per-connection state"
.PP
The temporary directory described above can be used for state for the
lifetime of the nbdkit instance (across multiple connections).  If you
want to store state per connection then one way to do it is to create
a randomly named subdirectory under the temporary directory:
.PP
.Vb 4
\& case "$1" in
\&   ...
\&   open)
\&     mktemp \-d $tmpdir/handle\-XXXXXX ;;
.Ve
.PP
The handle will be the subdirectory name, returned to the script as
\&\f(CW$2\fR in all connected calls (eg. \f(CW\*(C`pread\*(C'\fR, \f(CW\*(C`get_size\*(C'\fR).  You can
delete the subdirectory explicitly in \f(CW\*(C`close\*(C'\fR:
.PP
.Vb 4
\& case "$1" in
\&   ...
\&   close)
\&     rm \-rf "$2" ;;
.Ve
.PP
or rely on nbdkit deleting the whole temporary directory including all
per-handle subdirectories when it exits.
.SS "Performance"
.IX Subsection "Performance"
This plugin has to fork on every request, so performance will never be
great.  For best performance, consider using the \fInbdkit\-plugin\fR\|(3)
\&\s-1API\s0 directly.  Having said that, if you have a sh plugin and want to
improve performance then the following tips may help:
.IP "Relax the thread model." 4
.IX Item "Relax the thread model."
The default \f(CW\*(C`thread_model\*(C'\fR is \f(CW\*(C`serialize_all_requests\*(C'\fR meaning that
two instances of the script can never be running at the same time.
This is safe but slow.  If your script is safe to be called in
parallel, set this to \f(CW\*(C`parallel\*(C'\fR.
.ie n .IP "Implement the ""zero"" method." 4
.el .IP "Implement the \f(CWzero\fR method." 4
.IX Item "Implement the zero method."
If the \f(CW\*(C`zero\*(C'\fR method is not implemented then nbdkit will fall back to
using \f(CW\*(C`pwrite\*(C'\fR which is considerably slower because nbdkit has to
send blocks of zeroes to the script.
.IP "You don't have to write shell scripts." 4
.IX Item "You don't have to write shell scripts."
This plugin can run any external binary, not only shell scripts.  You
should get more performance by rewriting the shell script as a program
in a compiled language.
.SS "Methods"
.IX Subsection "Methods"
This just documents the arguments to the script corresponding to each
plugin method, and any way that they differ from the C callbacks.  In
all other respects they work the same way as the C callbacks, so you
should go and read \fInbdkit\-plugin\fR\|(3).
.ie n .IP """load""" 4
.el .IP "\f(CWload\fR" 4
.IX Item "load"
.Vb 1
\& /path/to/script load
.Ve
.ie n .IP """unload""" 4
.el .IP "\f(CWunload\fR" 4
.IX Item "unload"
.Vb 1
\& /path/to/script unload
.Ve
.Sp
This is called just before nbdkit exits.  Errors from this method are
ignored.
.ie n .IP """dump_plugin""" 4
.el .IP "\f(CWdump_plugin\fR" 4
.IX Item "dump_plugin"
.Vb 1
\& /path/to/script dump_plugin
.Ve
.ie n .IP """config""" 4
.el .IP "\f(CWconfig\fR" 4
.IX Item "config"
.Vb 1
\& /path/to/script config <key> <value>
.Ve
.ie n .IP """config_complete""" 4
.el .IP "\f(CWconfig_complete\fR" 4
.IX Item "config_complete"
.Vb 1
\& /path/to/script config_complete
.Ve
.ie n .IP """magic_config_key""" 4
.el .IP "\f(CWmagic_config_key\fR" 4
.IX Item "magic_config_key"
.Vb 1
\& /path/to/script magic_config_key
.Ve
.Sp
If a magic config key is needed, this should echo it to stdout.
See \*(L"Magic parameters\*(R" in \fInbdkit\fR\|(1).
.ie n .IP """thread_model""" 4
.el .IP "\f(CWthread_model\fR" 4
.IX Item "thread_model"
.Vb 1
\& /path/to/script thread_model
.Ve
.Sp
On success this should print the desired thread model of the script,
one of \f(CW"serialize_connections"\fR, \f(CW"serialize_all_requests"\fR,
\&\f(CW"serialize_requests"\fR, or \f(CW"parallel"\fR.
.Sp
This method is \fInot\fR required; if omitted, then the plugin will be
executed under the safe \f(CW"serialize_all_requests"\fR model.  However,
this means that this method \fBmust\fR be provided if you want to use the
\&\f(CW"parallel"\fR or \f(CW"serialize_requests"\fR model.  Even then your
request may be restricted for other reasons; look for \f(CW\*(C`thread_model\*(C'\fR
in the output of \f(CW\*(C`nbdkit \-\-dump\-plugin sh script\*(C'\fR to see what
actually gets selected.
.Sp
If an error occurs, the script should output an error message and exit
with status \f(CW1\fR; unrecognized output is ignored.
.ie n .IP """get_ready""" 4
.el .IP "\f(CWget_ready\fR" 4
.IX Item "get_ready"
.Vb 1
\& /path/to/script get_ready
.Ve
.ie n .IP """preconnect""" 4
.el .IP "\f(CWpreconnect\fR" 4
.IX Item "preconnect"
.Vb 1
\& /path/to/script preconnect <readonly> <exportname>
.Ve
.ie n .IP """open""" 4
.el .IP "\f(CWopen\fR" 4
.IX Item "open"
.Vb 1
\& /path/to/script open <readonly> <exportname>
.Ve
.Sp
The \f(CW\*(C`readonly\*(C'\fR parameter will be \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR.  The
\&\f(CW\*(C`exportname\*(C'\fR parameter, if present, is the export name passed to the
server from the client.
.Sp
On success this should print the handle (any string) on stdout and
exit with code \f(CW0\fR.  If the handle ends with a newline character then
the newline is removed.
.Sp
Unlike C plugins, this method is \fInot\fR required.  If omitted then the
handle will be \f(CW""\fR (empty string).
.ie n .IP """close""" 4
.el .IP "\f(CWclose\fR" 4
.IX Item "close"
.Vb 1
\& /path/to/script close <handle>
.Ve
.ie n .IP """get_size""" 4
.el .IP "\f(CWget_size\fR" 4
.IX Item "get_size"
.Vb 1
\& /path/to/script get_size <handle>
.Ve
.Sp
The script should print the size of the disk image on stdout.  You can
print the size in bytes, or use any format understood by
\&\f(CW\*(C`nbdkit_parse_size\*(C'\fR such as \f(CW\*(C`1M\*(C'\fR (see
\&\*(L"\s-1PARSING SIZE PARAMETERS\*(R"\s0 in \fInbdkit\-plugin\fR\|(3)).
.Sp
This method is required.
.ie n .IP """can_write""" 4
.el .IP "\f(CWcan_write\fR" 4
.IX Item "can_write"
.PD 0
.ie n .IP """can_flush""" 4
.el .IP "\f(CWcan_flush\fR" 4
.IX Item "can_flush"
.ie n .IP """can_trim""" 4
.el .IP "\f(CWcan_trim\fR" 4
.IX Item "can_trim"
.ie n .IP """can_zero""" 4
.el .IP "\f(CWcan_zero\fR" 4
.IX Item "can_zero"
.ie n .IP """can_extents""" 4
.el .IP "\f(CWcan_extents\fR" 4
.IX Item "can_extents"
.PD
Unlike in other languages, you \fBmust\fR provide the \f(CW\*(C`can_*\*(C'\fR methods
otherwise they are assumed to all return false and your \f(CW\*(C`pwrite\*(C'\fR,
\&\f(CW\*(C`flush\*(C'\fR, \f(CW\*(C`trim\*(C'\fR, \f(CW\*(C`zero\*(C'\fR and \f(CW\*(C`extents\*(C'\fR methods will never be
called.  The reason for this is obscure: In other languages we can
detect if (eg) a \f(CW\*(C`pwrite\*(C'\fR method is defined and synthesize an
appropriate response if no actual \f(CW\*(C`can_write\*(C'\fR method is defined.
However detecting if methods are present without running them is not
possible with this plugin.
.Sp
.Vb 5
\& /path/to/script can_write <handle>
\& /path/to/script can_flush <handle>
\& /path/to/script can_trim <handle>
\& /path/to/script can_zero <handle>
\& /path/to/script can_extents <handle>
.Ve
.Sp
The script should exit with code \f(CW0\fR for true or code \f(CW3\fR for false.
.ie n .IP """is_rotational""" 4
.el .IP "\f(CWis_rotational\fR" 4
.IX Item "is_rotational"
.PD 0
.ie n .IP """can_fast_zero""" 4
.el .IP "\f(CWcan_fast_zero\fR" 4
.IX Item "can_fast_zero"
.PD
.Vb 2
\& /path/to/script is_rotational <handle>
\& /path/to/script can_fast_zero <handle>
.Ve
.Sp
The script should exit with code \f(CW0\fR for true or code \f(CW3\fR for false.
.ie n .IP """can_fua""" 4
.el .IP "\f(CWcan_fua\fR" 4
.IX Item "can_fua"
.PD 0
.ie n .IP """can_cache""" 4
.el .IP "\f(CWcan_cache\fR" 4
.IX Item "can_cache"
.PD
.Vb 2
\& /path/to/script can_fua <handle>
\& /path/to/script can_cache <handle>
.Ve
.Sp
These control Forced Unit Access (\s-1FUA\s0) and caching behaviour of the
core server.
.Sp
Unlike the other \f(CW\*(C`can_*\*(C'\fR callbacks, these two are \fInot\fR a boolean.
They must print either \*(L"none\*(R", \*(L"emulate\*(R" or \*(L"native\*(R" to stdout.  The
meaning of these is described in \fInbdkit\-plugin\fR\|(3).  Furthermore,
you \fBmust\fR provide a \f(CW\*(C`can_cache\*(C'\fR method if you desire the \f(CW\*(C`cache\*(C'\fR
callback to be utilized, similar to the reasoning behind requiring
\&\f(CW\*(C`can_write\*(C'\fR to utilize \f(CW\*(C`pwrite\*(C'\fR.
.ie n .IP """can_multi_conn""" 4
.el .IP "\f(CWcan_multi_conn\fR" 4
.IX Item "can_multi_conn"
.Vb 1
\& /path/to/script can_multi_conn <handle>
.Ve
.Sp
The script should exit with code \f(CW0\fR for true or code \f(CW3\fR for false.
.ie n .IP """pread""" 4
.el .IP "\f(CWpread\fR" 4
.IX Item "pread"
.Vb 1
\& /path/to/script pread <handle> <count> <offset>
.Ve
.Sp
The script should print the requested binary data on stdout.  Exactly
\&\f(CW\*(C`count\*(C'\fR bytes must be printed.
.Sp
This method is required.
.ie n .IP """pwrite""" 4
.el .IP "\f(CWpwrite\fR" 4
.IX Item "pwrite"
.Vb 1
\& /path/to/script pwrite <handle> <count> <offset> <flags>
.Ve
.Sp
The script should read the binary data to be written from stdin.
.Sp
The \f(CW\*(C`flags\*(C'\fR parameter can be an empty string or \f(CW"fua"\fR.  In the
future, a comma-separated list of flags may be present.
.Sp
Unlike in other languages, if you provide a \f(CW\*(C`pwrite\*(C'\fR method you
\&\fBmust\fR also provide a \f(CW\*(C`can_write\*(C'\fR method which exits with code \f(CW0\fR
(true).
.ie n .IP """flush""" 4
.el .IP "\f(CWflush\fR" 4
.IX Item "flush"
.Vb 1
\& /path/to/script flush <handle>
.Ve
.Sp
Unlike in other languages, if you provide a \f(CW\*(C`flush\*(C'\fR method you
\&\fBmust\fR also provide a \f(CW\*(C`can_flush\*(C'\fR method which exits with code \f(CW0\fR
(true).
.ie n .IP """trim""" 4
.el .IP "\f(CWtrim\fR" 4
.IX Item "trim"
.Vb 1
\& /path/to/script trim <handle> <count> <offset> <flags>
.Ve
.Sp
The \f(CW\*(C`flags\*(C'\fR parameter can be an empty string or \f(CW"fua"\fR.  In the
future, a comma-separated list of flags may be present.
.Sp
Unlike in other languages, if you provide a \f(CW\*(C`trim\*(C'\fR method you \fBmust\fR
also provide a \f(CW\*(C`can_trim\*(C'\fR method which exits with code \f(CW0\fR (true).
.ie n .IP """zero""" 4
.el .IP "\f(CWzero\fR" 4
.IX Item "zero"
.Vb 1
\& /path/to/script zero <handle> <count> <offset> <flags>
.Ve
.Sp
The \f(CW\*(C`flags\*(C'\fR parameter can be an empty string or a comma-separated
list of the flags: \f(CW"fua"\fR, \f(CW"may_trim"\fR, and \f(CW"fast"\fR (eg. \f(CW""\fR,
\&\f(CW"fua"\fR, \f(CW"fua,may_trim,fast"\fR are some of the 8 possible values).
.Sp
Unlike in other languages, if you provide a \f(CW\*(C`zero\*(C'\fR method you \fBmust\fR
also provide a \f(CW\*(C`can_zero\*(C'\fR method which exits with code \f(CW0\fR (true).
.Sp
To trigger a fallback to <pwrite> on a normal zero request, or to
respond quickly to the \f(CW"fast"\fR flag that a specific zero request is
no faster than a corresponding write, the script must output
\&\f(CW\*(C`ENOTSUP\*(C'\fR or \f(CW\*(C`EOPNOTSUPP\*(C'\fR to stderr (possibly followed by a
description of the problem) before exiting with code \f(CW1\fR (failure).
.ie n .IP """extents""" 4
.el .IP "\f(CWextents\fR" 4
.IX Item "extents"
.Vb 1
\& /path/to/script extents <handle> <count> <offset> <flags>
.Ve
.Sp
The \f(CW\*(C`flags\*(C'\fR parameter can be an empty string or \f(CW"req_one"\fR.
.Sp
This must print, one per line on stdout, a list of one or more extents
in the format:
.Sp
.Vb 1
\& offset length type
.Ve
.Sp
which correspond to the inputs of the C \f(CW\*(C`nbdkit_add_extent\*(C'\fR function
(see \fInbdkit\-plugin\fR\|(3)).  The \f(CW\*(C`offset\*(C'\fR and \f(CW\*(C`length\*(C'\fR fields may use
any format understood by \f(CW\*(C`nbdkit_parse_size\*(C'\fR.  The optional \f(CW\*(C`type\*(C'\fR
field may be an integer, missing (same as 0), or a comma-separated
list of the words \f(CW\*(C`hole\*(C'\fR and \f(CW\*(C`zero\*(C'\fR.  An example of a valid set of
extents covering a \f(CW\*(C`10M\*(C'\fR disk where the first megabyte only is
allocated data:
.Sp
.Vb 2
\& 0  1M
\& 1M 9M  hole,zero
.Ve
.Sp
Unlike in other languages, if you provide an \f(CW\*(C`extents\*(C'\fR method you
\&\fBmust\fR also provide a \f(CW\*(C`can_extents\*(C'\fR method which exits with code
\&\f(CW0\fR (true).
.ie n .IP """cache""" 4
.el .IP "\f(CWcache\fR" 4
.IX Item "cache"
.Vb 1
\& /path/to/script cache <handle> <count> <offset>
.Ve
.Sp
Unlike in other languages, if you provide a \f(CW\*(C`cache\*(C'\fR method you
\&\fBmust\fR also provide a \f(CW\*(C`can_cache\*(C'\fR method which prints \*(L"native\*(R" and
exits with code \f(CW0\fR (true).
.SS "Missing callbacks"
.IX Subsection "Missing callbacks"
.ie n .IP "Missing: ""name"", ""version"", ""longname"", ""description"", ""config_help""" 4
.el .IP "Missing: \f(CWname\fR, \f(CWversion\fR, \f(CWlongname\fR, \f(CWdescription\fR, \f(CWconfig_help\fR" 4
.IX Item "Missing: name, version, longname, description, config_help"
These are not yet supported.
.SH "FILES"
.IX Header "FILES"
.IP "\fI\f(CI$plugindir\fI/nbdkit\-sh\-plugin.so\fR" 4
.IX Item "$plugindir/nbdkit-sh-plugin.so"
The plugin.
.Sp
Use \f(CW\*(C`nbdkit \-\-dump\-config\*(C'\fR to find the location of \f(CW$plugindir\fR.
.SH "VERSION"
.IX Header "VERSION"
\&\f(CW\*(C`nbdkit\-sh\-plugin\*(C'\fR first appeared in nbdkit 1.8.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fInbdkit\fR\|(1),
\&\fInbdkit\-plugin\fR\|(3),
\&\fInbdkit\-eval\-plugin\fR\|(1),
\&\fInbdkit\-cc\-plugin\fR\|(1).
.SH "AUTHORS"
.IX Header "AUTHORS"
Richard W.M. Jones
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2018\-2020 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:
.IP "\(bu" 4
Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
.IP "\(bu" 4
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
.IP "\(bu" 4
Neither the name of Red Hat nor the names of its contributors may be
used to endorse or promote products derived from this software without
specific prior written permission.
.PP
\&\s-1THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS\s0 ''\s-1AS IS\s0'' \s-1AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\s0 (\s-1INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES\s0; \s-1LOSS OF
USE, DATA, OR PROFITS\s0; \s-1OR BUSINESS INTERRUPTION\s0) \s-1HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT\s0 (\s-1INCLUDING NEGLIGENCE OR OTHERWISE\s0) \s-1ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.\s0
