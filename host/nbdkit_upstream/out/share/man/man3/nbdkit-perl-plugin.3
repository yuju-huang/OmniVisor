.\" Automatically generated by Podwrapper::Man 1.21.8 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "nbdkit-perl-plugin 3"
.TH nbdkit-perl-plugin 3 "2020-06-10" "nbdkit-1.21.8" "NBDKIT"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
nbdkit\-perl\-plugin \- nbdkit perl plugin
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& nbdkit perl /path/to/plugin.pl [arguments...]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`nbdkit\-perl\-plugin\*(C'\fR is an embedded Perl interpreter for
\&\fInbdkit\fR\|(1), allowing you to write nbdkit plugins in Perl.
.SS "If you have been given an nbdkit Perl plugin"
.IX Subsection "If you have been given an nbdkit Perl plugin"
Assuming you have a Perl script which is an nbdkit plugin, you run it
like this:
.PP
.Vb 1
\& nbdkit perl /path/to/plugin.pl
.Ve
.PP
You may have to add further \f(CW\*(C`key=value\*(C'\fR arguments to the command
line.  Read the Perl script to see if it requires any.
.SH "WRITING A PERL NBDKIT PLUGIN"
.IX Header "WRITING A PERL NBDKIT PLUGIN"
For an example plugin written in Perl, see:
https://github.com/libguestfs/nbdkit/blob/master/plugins/perl/example.pl
.PP
Broadly speaking, Perl nbdkit plugins work like C ones, so you should
read \fInbdkit\-plugin\fR\|(3) first.
.PP
To write a Perl nbdkit plugin, you create a Perl file which contains
at least the following required subroutines:
.PP
.Vb 12
\& sub open
\& {
\&   # see below
\& }
\& sub get_size
\& {
\&   # see below
\& }
\& sub pread
\& {
\&   # see below
\& }
.Ve
.PP
Note that the subroutines must have those literal names (like
\&\f(CW\*(C`open\*(C'\fR), because the C part looks up and calls those functions
directly.  You may want to include documentation and globals (eg. for
storing global state).  Also any top-level statements, \f(CW\*(C`BEGIN\*(C'\fR
statements, \f(CW\*(C`END\*(C'\fR statements and so on are run when nbdkit starts up
and shuts down, just like ordinary Perl.
.SS "Executable script"
.IX Subsection "Executable script"
If you want you can make the script executable and include a \*(L"shebang\*(R"
at the top:
.PP
.Vb 1
\& #!/usr/sbin/nbdkit perl
.Ve
.PP
See also \*(L"Shebang scripts\*(R" in \fInbdkit\fR\|(1).
.PP
These scripts can also be installed in the \f(CW$plugindir\fR.  See
\&\*(L"\s-1WRITING PLUGINS IN OTHER PROGRAMMING LANGUAGES\*(R"\s0 in \fInbdkit\-plugin\fR\|(3).
.ie n .SS """Nbdkit::"" functions"
.el .SS "\f(CWNbdkit::\fP functions"
.IX Subsection "Nbdkit:: functions"
The following functions can be called in a virtual Perl package called
\&\f(CW\*(C`Nbdkit\*(C'\fR.  Your script does not need to \*(L"use\*(R" this package, it is
already available in all scripts.
.PP
\fI\f(CI\*(C`Nbdkit::debug ($msg)\*(C'\fI\fR
.IX Subsection "Nbdkit::debug ($msg)"
.PP
In debugging mode, print \f(CW$msg\fR.  This is a wrapper around the C
function \f(CW\*(C`nbdkit_debug\*(C'\fR (see \fInbdkit\-plugin\fR\|(3)).
.PP
\fI\f(CI\*(C`Nbdkit::set_error ($err)\*(C'\fI\fR
.IX Subsection "Nbdkit::set_error ($err)"
.PP
.Vb 1
\& Nbdkit::set_error($err);
.Ve
.PP
Record \f(CW$err\fR as the reason you are about to throw an exception.
\&\f(CW$err\fR should correspond to usual errno values, where it may help to
\&\f(CW\*(C`use POSIX()\*(C'\fR.
.SS "Exceptions"
.IX Subsection "Exceptions"
Instead of returning error codes as in C, Perl callbacks should
indicate problems by throwing Perl exceptions (ie. \f(CW\*(C`die\*(C'\fR, \f(CW\*(C`croak\*(C'\fR
etc).  The Perl error message is captured and printed by nbdkit.
Remember to use \f(CW\*(C`Nbdkit::set_error\*(C'\fR if you need to control which
error is sent back to the client; if omitted, the client will see an
error of \f(CW\*(C`EIO\*(C'\fR.
.SS "32 vs 64 bit"
.IX Subsection "32 vs 64 bit"
It is likely that Perl plugins won't work well, or maybe won't work at
all, on 32 bit platforms.  This is simply because Perl doesn't have an
easy way to use 64 bit integers on 32 bit platforms, and 64 bit
integers (eg. file offsets, disk sizes) are required for many nbdkit
operations.
.SS "Perl callbacks"
.IX Subsection "Perl callbacks"
This just documents the arguments to the callbacks in Perl, and any
way that they differ from the C callbacks.  In all other respects they
work the same way as the C callbacks, so you should go and read
\&\fInbdkit\-plugin\fR\|(3).
.ie n .IP """dump_plugin""" 4
.el .IP "\f(CWdump_plugin\fR" 4
.IX Item "dump_plugin"
(Optional)
.Sp
There are no arguments or return value.
.ie n .IP """config""" 4
.el .IP "\f(CWconfig\fR" 4
.IX Item "config"
(Optional)
.Sp
.Vb 6
\& sub config
\& {
\&     my $key = shift;
\&     my $value = shift;
\&     # No return value.
\& }
.Ve
.ie n .IP """config_complete""" 4
.el .IP "\f(CWconfig_complete\fR" 4
.IX Item "config_complete"
(Optional)
.Sp
There are no arguments or return value.
.ie n .IP """open""" 4
.el .IP "\f(CWopen\fR" 4
.IX Item "open"
(Required)
.Sp
.Vb 6
\& sub open
\& {
\&     my $readonly = shift;
\&     my $handle = {};
\&     return $handle;
\& }
.Ve
.Sp
The \f(CW\*(C`readonly\*(C'\fR flag is a boolean.
.Sp
You can return any Perl value as the handle.  It is passed back to
subsequent calls.  It's usually convenient to use a hashref, since
that lets you store arbitrary fields.
.ie n .IP """close""" 4
.el .IP "\f(CWclose\fR" 4
.IX Item "close"
(Optional)
.Sp
.Vb 5
\& sub close
\& {
\&     my $handle = shift;
\&     # No return value
\& }
.Ve
.Sp
After \f(CW\*(C`close\*(C'\fR returns, the reference count of the handle is
decremented in the C part, which usually means that the handle and its
contents will be garbage collected.
.ie n .IP """get_size""" 4
.el .IP "\f(CWget_size\fR" 4
.IX Item "get_size"
(Required)
.Sp
.Vb 6
\& sub get_size
\& {
\&     my $handle = shift;
\&     my $i64 = .. the size of the disk ..;
\&     return $i64;
\& }
.Ve
.Sp
This returns the size of the disk.  You can return any Perl object
that evaluates to an integer.
.ie n .IP """can_write""" 4
.el .IP "\f(CWcan_write\fR" 4
.IX Item "can_write"
(Optional)
.Sp
.Vb 6
\& sub can_write
\& {
\&     my $handle = shift;
\&     my $bool = ...;
\&     return $bool;
\& }
.Ve
.Sp
Return a boolean indicating whether the disk is writable.
.ie n .IP """can_flush""" 4
.el .IP "\f(CWcan_flush\fR" 4
.IX Item "can_flush"
(Optional)
.Sp
.Vb 6
\& sub can_flush
\& {
\&     my $handle = shift;
\&     my $bool = ...;
\&     return $bool;
\& }
.Ve
.Sp
Return a boolean indicating whether flush can be performed.
.ie n .IP """is_rotational""" 4
.el .IP "\f(CWis_rotational\fR" 4
.IX Item "is_rotational"
(Optional)
.Sp
.Vb 6
\& sub is_rotational
\& {
\&     my $handle = shift;
\&     my $bool = ...;
\&     return $bool;
\& }
.Ve
.Sp
Return a boolean indicating whether the disk is rotational.
.ie n .IP """can_trim""" 4
.el .IP "\f(CWcan_trim\fR" 4
.IX Item "can_trim"
(Optional)
.Sp
.Vb 6
\& sub can_trim
\& {
\&     my $handle = shift;
\&     my $bool = ...;
\&     return $bool;
\& }
.Ve
.Sp
Return a boolean indicating whether trim/discard can be performed.
.ie n .IP """pread""" 4
.el .IP "\f(CWpread\fR" 4
.IX Item "pread"
(Required)
.Sp
.Vb 9
\& sub pread
\& {
\&    my $handle = shift;
\&    my $count = shift;
\&    my $offset = shift;
\&    my $flags = shift;
\&    # Construct a buffer of length $count bytes and return it.
\&    return $buf;
\& }
.Ve
.Sp
The body of your \f(CW\*(C`pread\*(C'\fR function should construct a buffer of length
(at least) \f(CW$count\fR bytes.  You should read \f(CW$count\fR bytes from the
disk starting at \f(CW$offset\fR.
.Sp
\&\s-1NBD\s0 only supports whole reads, so your function should try to read the
whole region (perhaps requiring a loop).  If the read fails or is
partial, your function should \f(CW\*(C`die\*(C'\fR, optionally using
\&\f(CW\*(C`Nbdkit::set_error\*(C'\fR first.
.ie n .IP """pwrite""" 4
.el .IP "\f(CWpwrite\fR" 4
.IX Item "pwrite"
(Optional)
.Sp
.Vb 9
\& sub pwrite
\& {
\&    my $handle = shift;
\&    my $buf = shift;
\&    my $count = length ($buf);
\&    my $offset = shift;
\&    my $flags = shift;
\&    # No return value
\& }
.Ve
.Sp
The body of your \f(CW\*(C`pwrite\*(C'\fR function should write the \f(CW$buf\fR string to
the disk.  You should write \f(CW$count\fR bytes to the disk starting at
\&\f(CW$offset\fR.
.Sp
\&\s-1NBD\s0 only supports whole writes, so your function should try to write
the whole region (perhaps requiring a loop).  If the write fails or is
partial, your function should \f(CW\*(C`die\*(C'\fR, optionally using
\&\f(CW\*(C`Nbdkit::set_error\*(C'\fR first.
.ie n .IP """flush""" 4
.el .IP "\f(CWflush\fR" 4
.IX Item "flush"
(Optional)
.Sp
.Vb 6
\& sub flush
\& {
\&    my $handle = shift;
\&    my $flags = shift;
\&    # No return value
\& }
.Ve
.Sp
The body of your \f(CW\*(C`flush\*(C'\fR function should do a \fIsync\fR\|(2) or
\&\fIfdatasync\fR\|(2) or equivalent on the backing store.
.Sp
If there is an error, the function should call \f(CW\*(C`die\*(C'\fR, optionally using
\&\f(CW\*(C`Nbdkit::set_error\*(C'\fR first.
.ie n .IP """trim""" 4
.el .IP "\f(CWtrim\fR" 4
.IX Item "trim"
(Optional)
.Sp
.Vb 8
\& sub trim
\& {
\&    my $handle = shift;
\&    my $count = shift;
\&    my $offset = shift;
\&    my $flags = shift;
\&    # No return value
\& }
.Ve
.Sp
The body of your \f(CW\*(C`trim\*(C'\fR function should \*(L"punch a hole\*(R" in the backing
store.
.Sp
If there is an error, the function should call \f(CW\*(C`die\*(C'\fR, optionally using
\&\f(CW\*(C`Nbdkit::set_error\*(C'\fR first.
.ie n .IP """zero""" 4
.el .IP "\f(CWzero\fR" 4
.IX Item "zero"
(Optional)
.Sp
.Vb 8
\& sub zero
\& {
\&    my $handle = shift;
\&    my $count = shift;
\&    my $offset = shift;
\&    my $flags = shift;
\&    # No return value
\& }
.Ve
.Sp
The body of your \f(CW\*(C`zero\*(C'\fR function should ensure that \f(CW$count\fR bytes
of the disk, starting at \f(CW$offset\fR, will read back as zero.
.Sp
\&\s-1NBD\s0 only supports whole writes, so your function should try to write
the whole region (perhaps requiring a loop).  If the write fails or is
partial, your function should \f(CW\*(C`die\*(C'\fR, optionally using
\&\f(CW\*(C`Nbdkit::set_error\*(C'\fR first.  In particular, if you would like to
automatically fall back to \f(CW\*(C`pwrite\*(C'\fR (perhaps because there is nothing
to optimize if \f(CW$flags\fR does not contain \f(CW$Nbdkit::FLAG_MAY_TRIM\fR), use
\&\f(CW\*(C`Nbdkit::set_error(POSIX::EOPNOTSUPP)\*(C'\fR.
.SS "Missing callbacks"
.IX Subsection "Missing callbacks"
.ie n .IP "Missing: ""load"" and ""unload""" 4
.el .IP "Missing: \f(CWload\fR and \f(CWunload\fR" 4
.IX Item "Missing: load and unload"
These are not needed because you can just use regular Perl \f(CW\*(C`BEGIN\*(C'\fR
and \f(CW\*(C`END\*(C'\fR constructs.
.ie n .IP "Missing: ""name"", ""version"", ""longname"", ""description"", ""config_help"", ""can_fua"", ""can_cache"", ""cache""" 4
.el .IP "Missing: \f(CWname\fR, \f(CWversion\fR, \f(CWlongname\fR, \f(CWdescription\fR, \f(CWconfig_help\fR, \f(CWcan_fua\fR, \f(CWcan_cache\fR, \f(CWcache\fR" 4
.IX Item "Missing: name, version, longname, description, config_help, can_fua, can_cache, cache"
These are not yet supported.
.SS "Threads"
.IX Subsection "Threads"
The thread model for Perl callbacks currently cannot be set from Perl.
It is hard-coded in the C part to
\&\f(CW\*(C`NBDKIT_THREAD_MODEL_SERIALIZE_ALL_REQUESTS\*(C'\fR.  This may change or be
settable in future.
.SH "FILES"
.IX Header "FILES"
.IP "\fI\f(CI$plugindir\fI/nbdkit\-perl\-plugin.so\fR" 4
.IX Item "$plugindir/nbdkit-perl-plugin.so"
The plugin.
.Sp
Use \f(CW\*(C`nbdkit \-\-dump\-config\*(C'\fR to find the location of \f(CW$plugindir\fR.
.SH "VERSION"
.IX Header "VERSION"
\&\f(CW\*(C`nbdkit\-perl\-plugin\*(C'\fR first appeared in nbdkit 1.2.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fInbdkit\fR\|(1),
\&\fInbdkit\-plugin\fR\|(3),
\&\fIperl\fR\|(1).
.SH "AUTHORS"
.IX Header "AUTHORS"
Eric Blake
.PP
Richard W.M. Jones
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2013\-2020 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:
.IP "\(bu" 4
Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
.IP "\(bu" 4
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
.IP "\(bu" 4
Neither the name of Red Hat nor the names of its contributors may be
used to endorse or promote products derived from this software without
specific prior written permission.
.PP
\&\s-1THIS SOFTWARE IS PROVIDED BY RED HAT AND CONTRIBUTORS\s0 ''\s-1AS IS\s0'' \s-1AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RED HAT OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\s0 (\s-1INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES\s0; \s-1LOSS OF
USE, DATA, OR PROFITS\s0; \s-1OR BUSINESS INTERRUPTION\s0) \s-1HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT\s0 (\s-1INCLUDING NEGLIGENCE OR OTHERWISE\s0) \s-1ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.\s0
