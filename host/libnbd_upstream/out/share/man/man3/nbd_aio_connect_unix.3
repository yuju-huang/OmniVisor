.\" Automatically generated by Podwrapper::Man 1.3.7 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "nbd_aio_connect_unix 3"
.TH nbd_aio_connect_unix 3 "2020-06-10" "libnbd-1.3.7" "LIBNBD"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
nbd_aio_connect_unix \- connect to the NBD server over a Unix domain socket
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <libnbd.h>
\&
\& int nbd_aio_connect_unix (struct nbd_handle *h,
\&                           const char *unixsocket);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Begin connecting to the \s-1NBD\s0 server over Unix domain socket
(\f(CW\*(C`unixsocket\*(C'\fR).  Parameters behave as documented in
\&\fInbd_connect_unix\fR\|(3).
.PP
You can check if the connection is still connecting by calling
\&\fInbd_aio_is_connecting\fR\|(3), or if it has connected to the server
and completed the \s-1NBD\s0 handshake by calling \fInbd_aio_is_ready\fR\|(3),
on the connection.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
If the call is successful the function returns \f(CW0\fR.
.SH "ERRORS"
.IX Header "ERRORS"
On error \f(CW\*(C`\-1\*(C'\fR is returned.
.PP
Refer to \*(L"\s-1ERROR HANDLING\*(R"\s0 in \fIlibnbd\fR\|(3)
for how to get further details of the error.
.SH "HANDLE STATE"
.IX Header "HANDLE STATE"
The handle must be
newly created,
otherwise this call will return an error.
.SH "VERSION"
.IX Header "VERSION"
This function first appeared in libnbd 1.0.
.PP
If you need to test if this function is available at compile time
check if the following macro is defined:
.PP
.Vb 1
\& #define LIBNBD_HAVE_NBD_AIO_CONNECT_UNIX 1
.Ve
.SH "EXAMPLE"
.IX Header "EXAMPLE"
This example is also available as \fIexamples/aio\-connect\-read.c\fR
in the libnbd source code.
.PP
.Vb 10
\& /* This example shows how to use the AIO (asynchronous) low
\&  * level API to connect to a server and read the disk.
\&  *
\&  * Here are a few ways to try this example:
\&  *
\&  * nbdkit \-U \- linuxdisk . \e
\&  *   \-\-run \*(Aq./aio\-connect\-read $unixsocket\*(Aq
\&  *
\&  * nbdkit \-U \- floppy . \e
\&  *   \-\-run \*(Aq./aio\-connect\-read $unixsocket\*(Aq
\&  *
\&  * nbdkit \-U \- pattern size=1M \e
\&  *   \-\-run \*(Aq./aio\-connect\-read $unixsocket\*(Aq
\&  */
\& 
\& #include <stdio.h>
\& #include <stdlib.h>
\& #include <stdint.h>
\& #include <inttypes.h>
\& #include <assert.h>
\& 
\& #include <libnbd.h>
\& 
\& #define NR_SECTORS 32
\& #define SECTOR_SIZE 512
\& 
\& struct data {
\&   uint64_t offset;
\&   char sector[SECTOR_SIZE];
\& };
\& 
\& static int
\& hexdump (void *user_data, int *error)
\& {
\&   struct data *data = user_data;
\&   FILE *pp;
\& 
\&   printf ("sector at offset 0x%" PRIx64 ":\en",
\&           data\->offset);
\&   pp = popen ("hexdump \-C", "w");
\&   if (pp == NULL) {
\&     perror ("popen: hexdump");
\&     exit (EXIT_FAILURE);
\&   }
\&   fwrite (data\->sector, SECTOR_SIZE, 1, pp);
\&   pclose (pp);
\&   printf ("\en");
\& 
\&   /* Returning 1 from the callback automatically retires
\&    * the command.
\&    */
\&   return 1;
\& }
\& 
\& int
\& main (int argc, char *argv[])
\& {
\&   struct nbd_handle *nbd;
\&   struct data data[NR_SECTORS];
\&   size_t i;
\& 
\&   if (argc != 2) {
\&     fprintf (stderr, "%s socket\en", argv[0]);
\&     exit (EXIT_FAILURE);
\&   }
\& 
\&   /* Create the libnbd handle. */
\&   nbd = nbd_create ();
\&   if (nbd == NULL) {
\&     fprintf (stderr, "%s\en", nbd_get_error ());
\&     exit (EXIT_FAILURE);
\&   }
\& 
\&   /* Connect to the NBD server over a Unix domain socket.
\&    * This only starts the connection.
\&    */
\&   if (nbd_aio_connect_unix (nbd, argv[1]) == \-1) {
\&     fprintf (stderr, "%s\en", nbd_get_error ());
\&     exit (EXIT_FAILURE);
\&   }
\& 
\&   /* Wait for the connection to complete.  The use of
\&    * nbd_poll here is only as an example.  You could also
\&    * integrate this with poll(2), glib or another main
\&    * loop.  Read libnbd(3) and the source file lib/poll.c.
\&    */
\&   while (!nbd_aio_is_ready (nbd)) {
\&     if (nbd_poll (nbd, \-1) == \-1) {
\&       fprintf (stderr, "%s\en", nbd_get_error ());
\&       exit (EXIT_FAILURE);
\&     }
\&   }
\& 
\&   assert (nbd_get_size (nbd) >= NR_SECTORS * SECTOR_SIZE);
\& 
\&   /* Issue read commands for the first NR sectors. */
\&   for (i = 0; i < NR_SECTORS; ++i) {
\&     data[i].offset = i * SECTOR_SIZE;
\& 
\&     /* The callback (hexdump) is called when the command
\&      * completes.  The buffer must continue to exist while
\&      * the command is running.
\&      */
\&     if (nbd_aio_pread (nbd, data[i].sector, SECTOR_SIZE,
\&                        data[i].offset,
\&                        (nbd_completion_callback) {
\&                          .callback = hexdump,
\&                          .user_data = &data[i],
\&                        }, 0) == \-1) {
\&       fprintf (stderr, "%s\en", nbd_get_error ());
\&       exit (EXIT_FAILURE);
\&     }
\&   }
\& 
\&   /* Run the main loop until all the commands have
\&    * completed and retired.  Again the use of nbd_poll
\&    * here is only as an example.
\&    */
\&   while (nbd_aio_in_flight (nbd) > 0) {
\&     if (nbd_poll (nbd, \-1) == \-1) {
\&       fprintf (stderr, "%s\en", nbd_get_error ());
\&       exit (EXIT_FAILURE);
\&     }
\&   }
\& 
\&   /* Close the libnbd handle. */
\&   nbd_close (nbd);
\& 
\&   exit (EXIT_SUCCESS);
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fInbd_aio_is_connecting\fR\|(3),
\&\fInbd_aio_is_ready\fR\|(3),
\&\fInbd_connect_unix\fR\|(3),
\&\fInbd_create\fR\|(3),
\&\fIlibnbd\fR\|(3).
.SH "AUTHORS"
.IX Header "AUTHORS"
Eric Blake
.PP
Richard W.M. Jones
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2019 Red Hat Inc.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or
modify it under the terms of the \s-1GNU\s0 Lesser General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.
.PP
This library is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0  See the \s-1GNU\s0
Lesser General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, \s-1MA 02110\-1301 USA\s0
